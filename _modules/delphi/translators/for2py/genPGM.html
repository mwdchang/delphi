

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>delphi.translators.for2py.genPGM &mdash; delphi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script type="text/javascript" src="../../../../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> delphi
          

          
            
            <img src="../../../../_static/delphi_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../AnalysisGraph_API.html">AnalysisGraph API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_spec.html">Grounded Function Network (GrFN) JSON Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_spec.html#change-log">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cpp_api/library_root.html">C++ API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">delphi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../for2py.html">delphi.translators.for2py</a> &raquo;</li>
        
      <li>delphi.translators.for2py.genPGM</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for delphi.translators.for2py.genPGM</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python3.6</span>

<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.genCode</span> <span class="k">import</span> <span class="n">genCode</span><span class="p">,</span> <span class="n">PrintState</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.mod_index_generator</span> <span class="k">import</span> <span class="n">get_index</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py</span> <span class="k">import</span> <span class="n">For2PyError</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">uuid</span>


<span class="n">BINOPS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Sub</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Mult</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Div</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Pow</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Eq</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">LtE</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">ANNOTATE_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;real&quot;</span><span class="p">:</span> <span class="s2">&quot;Real&quot;</span><span class="p">,</span>
    <span class="s2">&quot;integer&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
    <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span><span class="p">,</span>
    <span class="s2">&quot;array&quot;</span><span class="p">:</span> <span class="s2">&quot;[]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">REVERSE_ANNOTATE_MAP</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
	<span class="s2">&quot;Real&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
	<span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
	<span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
	<span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
	<span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">UNNECESSARY_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Mult</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Sub</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Pow</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Div</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">LtE</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Regular expression to match python statements that need to be bypassed in</span>
<span class="c1"># the GrFN and lambda files. Currently contains I/O statements.</span>
<span class="n">BYPASS_IO</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^format_\d+$|^format_\d+_obj$|^file_\d+$|^write_list_\d+$|&quot;</span> \
            <span class="sa">r</span><span class="s2">&quot;^write_line$|^format_\d+_obj&quot;</span> \
            <span class="sa">r</span><span class="s2">&quot;.*|^Format$|^list_output_formats$|^write_list_stream$&quot;</span>

<span class="n">RE_BYPASS_IO</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">BYPASS_IO</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>


<div class="viewcode-block" id="GrFNGenerator"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator">[docs]</a><span class="k">class</span> <span class="nc">GrFNGenerator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annassigned_list</span><span class="o">=</span><span class="p">[],</span> <span class="n">elif_pgm</span><span class="o">=</span><span class="p">[],</span> <span class="n">function_defs</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annassigned_list</span> <span class="o">=</span> <span class="n">annassigned_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span> <span class="o">=</span> <span class="n">elif_pgm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_defs</span> <span class="o">=</span> <span class="n">function_defs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_mapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_function</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="GrFNGenerator.genPgm"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.genPgm">[docs]</a>    <span class="k">def</span> <span class="nf">genPgm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">fnName</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span><span class="p">}]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">If</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">cur</span> <span class="ow">in</span> <span class="n">node</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Function: name, args, body, decorator_list, returns</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">):</span>

            <span class="c1"># List out all the function definitions in the ast</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function_defs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_function</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>

            <span class="n">localDefs</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">localNext</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">localTypes</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">scope_path</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># Tracks the scope of the identifier</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">decorator_list</span><span class="p">:</span>
                <span class="c1"># This is still a work-in-progress function has a complete</span>
                <span class="c1"># representation of SAVEd variables has not been decided on.</span>
                <span class="c1"># Currently, if the decorator function is static_vars (for</span>
                <span class="c1"># SAVEd variables), their types are loaded in the varTypes</span>
                <span class="c1"># dictionary.</span>
                <span class="n">fnState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">lastDefs</span><span class="o">=</span><span class="n">localDefs</span><span class="p">,</span>
                    <span class="n">nextDefs</span><span class="o">=</span><span class="n">localNext</span><span class="p">,</span>
                    <span class="n">fnName</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">varTypes</span><span class="o">=</span><span class="n">localTypes</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_decorators</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">decorator_list</span><span class="p">,</span> <span class="n">fnState</span><span class="p">)</span>

            <span class="c1"># Check if the function contains arguments or not</span>
            <span class="c1"># This determines whether the function is the outermost scope</span>
            <span class="c1"># (does not contain arguments) or it is not (contains arguments)</span>
            <span class="c1"># For non-outermost scopes, indexing starts from -1</span>
            <span class="c1"># For outermost scopes, indexing starts from 0</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isouterScope</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">fnState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">lastDefs</span><span class="o">=</span><span class="n">localDefs</span><span class="p">,</span>
                    <span class="n">nextDefs</span><span class="o">=</span><span class="n">localNext</span><span class="p">,</span>
                    <span class="n">fnName</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">varTypes</span><span class="o">=</span><span class="n">localTypes</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isouterScope</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">fnlastDefs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">fnState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">lastDefs</span><span class="o">=</span><span class="n">fnlastDefs</span><span class="p">,</span>
                    <span class="n">nextDefs</span><span class="o">=</span><span class="p">{},</span>
                    <span class="n">fnName</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">varTypes</span><span class="o">=</span><span class="n">localTypes</span><span class="p">,</span>
                    <span class="n">lastDefDefault</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">fnState</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">)</span>
            <span class="n">bodyPgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">fnState</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">)</span>

            <span class="n">body</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">iden_spec</span> <span class="o">=</span> <span class="n">get_body_and_functions</span><span class="p">(</span><span class="n">bodyPgm</span><span class="p">)</span>

            <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">localDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">variables_tmp</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;(format_\d+_obj)|(file_\d+)|(write_list_\d+)|&quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;(write_line)&quot;</span><span class="p">,</span>
                    <span class="n">item</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                    <span class="n">variables_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="n">variables</span> <span class="o">=</span> <span class="n">variables_tmp</span>

            <span class="n">fnDef</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;container&quot;</span><span class="p">,</span>
                <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">localTypes</span><span class="p">[</span><span class="n">arg</span><span class="p">]}</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span>
                <span class="p">],</span>
                <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">var</span><span class="p">,</span> <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">localTypes</span><span class="p">[</span><span class="n">var</span><span class="p">]}</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span>
                <span class="p">],</span>
                <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="n">body</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="n">fns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fnDef</span><span class="p">)</span>

            <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="n">fns</span><span class="p">,</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="n">iden_spec</span><span class="p">}</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span>

        <span class="c1"># arguments: (&#39;args&#39;, &#39;vararg&#39;, &#39;kwonlyargs&#39;, &#39;kw_defaults&#39;, &#39;kwarg&#39;,</span>
        <span class="c1"># &#39;defaults&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">arguments</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span>
            <span class="p">]</span>

        <span class="c1"># arg: (&#39;arg&#39;, &#39;annotation&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">annotation</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">getVarType</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">):</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">call_source</span> <span class="o">==</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">arg</span>

        <span class="c1"># Load: ()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Load</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Found ast.Load, which should not happen.&quot;</span><span class="p">)</span>

        <span class="c1"># Store: ()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Found ast.Store, which should not happen.&quot;</span><span class="p">)</span>

        <span class="c1"># Index: (&#39;value&#39;,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Index</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span>

        <span class="c1"># Num: (&#39;n&#39;,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">getDType</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="p">}</span>
            <span class="p">]</span>

        <span class="c1"># List: (&#39;elts&#39;, &#39;ctx&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">List</span><span class="p">):</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">elmt</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;List&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">elmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span>
                <span class="p">]</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">elements</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[{</span><span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="n">elements</span><span class="p">}]</span>

        <span class="c1"># Str: (&#39;s&#39;,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Str</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">s</span><span class="p">}]</span>

        <span class="c1"># For: (&#39;target&#39;, &#39;iter&#39;, &#39;body&#39;, &#39;orelse&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">For</span><span class="p">):</span>

            <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;loop&quot;</span><span class="p">)</span>

            <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">lastDefs</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">nextDefs</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">lastDefDefault</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span><span class="p">,</span>
                <span class="n">fnName</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">fnName</span><span class="p">,</span>
                <span class="n">varTypes</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">lambdaStrings</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">lambdaStrings</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">scope_path</span><span class="o">=</span><span class="n">scope_path</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;For/Else in for not supported.&quot;</span><span class="p">)</span>

            <span class="n">indexVar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexVar</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="s2">&quot;var&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indexVar</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Only one index variable is supported.&quot;</span><span class="p">)</span>
            <span class="n">indexName</span> <span class="o">=</span> <span class="n">indexVar</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
            <span class="n">loopIter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">loopIter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="s2">&quot;call&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loopIter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">loopIter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;range&quot;</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Can only iterate over a range.&quot;</span><span class="p">)</span>

            <span class="n">rangeCall</span> <span class="o">=</span> <span class="n">loopIter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span>
                <span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Can only iterate over a constant range.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">iterationRange</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">}</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">iterationRange</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">}</span>

            <span class="n">loopLastDef</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">loopState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">lastDefs</span><span class="o">=</span><span class="n">loopLastDef</span><span class="p">,</span> <span class="n">nextDefs</span><span class="o">=</span><span class="p">{},</span> <span class="n">lastDefDefault</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>

            <span class="n">loopState</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">[</span><span class="n">indexName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">loop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">loopState</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>

            <span class="n">loopBody</span><span class="p">,</span> <span class="n">loopFns</span><span class="p">,</span> <span class="n">iden_spec</span> <span class="o">=</span> <span class="n">get_body_and_functions</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>

            <span class="c1"># If loopLastDef[x] == 0, this means that the variable was not</span>
            <span class="c1"># declared before the loop and is being declared/defined within</span>
            <span class="c1"># the loop. So we need to remove that from the variable_list</span>
            <span class="n">variable_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">loopLastDef</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">indexName</span> <span class="ow">and</span>
                                                        <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)]</span>

            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">[</span><span class="n">variable</span><span class="p">]}</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variable_list</span>
                <span class="p">]</span>

            <span class="c1"># Removing the indexing of the loop index variable from the loopName</span>
            <span class="c1"># loopName = getFnName(</span>
            <span class="c1">#     fnNames, f&quot;{state.fnName}__loop_plate__{indexName}&quot;, {}</span>
            <span class="c1"># )</span>

            <span class="n">loopName</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">fnName</span> <span class="o">+</span> <span class="s2">&quot;__loop_plate__&quot;</span> <span class="o">+</span> <span class="n">indexName</span>

            <span class="n">loopFn</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">loopName</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;loop_plate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">variables</span><span class="p">,</span>
                <span class="s2">&quot;index_variable&quot;</span><span class="p">:</span> <span class="n">indexName</span><span class="p">,</span>
                <span class="s2">&quot;index_iteration_range&quot;</span><span class="p">:</span> <span class="n">iterationRange</span><span class="p">,</span>
                <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="n">loopBody</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
                <span class="n">loopName</span><span class="p">,</span> <span class="n">indexName</span><span class="p">,</span> <span class="p">{},</span> <span class="n">state</span>
            <span class="p">)</span>
            <span class="n">loopCall</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">loopName</span><span class="p">,</span>
                <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span>
                        <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">loopState</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
                    <span class="p">}</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variable_list</span>
                <span class="p">],</span>
                <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">{}</span>
            <span class="p">}</span>

            <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="n">loopFns</span> <span class="o">+</span> <span class="p">[</span><span class="n">loopFn</span><span class="p">],</span>
                <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">loopCall</span><span class="p">],</span>
                <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span>

        <span class="c1"># If: (&#39;test&#39;, &#39;body&#39;, &#39;orelse&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">If</span><span class="p">):</span>

            <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;if&quot;</span><span class="p">)</span>

            <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span> <span class="o">=</span> <span class="n">scope_path</span>

            <span class="k">if</span> <span class="n">call_source</span> <span class="o">==</span> <span class="s2">&quot;if&quot;</span><span class="p">:</span>
                <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

                <span class="n">condSrcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>

                <span class="n">startDefs</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">ifDefs</span> <span class="o">=</span> <span class="n">startDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">elseDefs</span> <span class="o">=</span> <span class="n">startDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">ifState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lastDefs</span><span class="o">=</span><span class="n">ifDefs</span><span class="p">)</span>
                <span class="n">elseState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lastDefs</span><span class="o">=</span><span class="n">elseDefs</span><span class="p">)</span>
                <span class="n">ifPgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">ifState</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>
                <span class="n">elsePgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">elseState</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>

                <span class="n">updatedDefs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">var</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">startDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">ifDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">elseDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">startDefs</span>
                    <span class="ow">or</span> <span class="n">ifDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">startDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">elseDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">startDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                <span class="p">]</span>

                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span>
                    <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">ifPgm</span>
                <span class="p">)</span> <span class="o">+</span> <span class="n">reduce</span><span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">elsePgm</span><span class="p">)</span>

                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span>
                    <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">ifPgm</span>
                <span class="p">)</span> <span class="o">+</span> <span class="n">reduce</span><span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">elsePgm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">pgm</span><span class="p">,</span>
                    <span class="n">condSrcs</span><span class="p">,</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">updatedDefs</span><span class="p">,</span>
                    <span class="n">ifDefs</span><span class="p">,</span>
                    <span class="n">state</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

            <span class="n">condSrcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>

            <span class="c1"># Making the index of IF_X_X start from 1 instead of 2</span>
            <span class="n">condNum</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;#cond&quot;</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">condNum</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">condName</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;IF_</span><span class="si">{condNum}</span><span class="s2">&quot;</span>
            <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">[</span><span class="n">condName</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>
            <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">[</span><span class="n">condName</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">fnName</span> <span class="o">=</span> <span class="n">getFnName</span><span class="p">(</span>
                <span class="n">fnNames</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.fnName}</span><span class="s2">__condition__</span><span class="si">{condName}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{}</span>
            <span class="p">)</span>

            <span class="c1"># The condName is of the form &#39;IF_1&#39; and the index holds the</span>
            <span class="c1"># ordering of the condName. This means that index should increment</span>
            <span class="c1"># of every new &#39;IF&#39; statement. Previously, it was set to set to 0.</span>
            <span class="c1"># But, &#39;fnName&#39; holds the current index of &#39;condName&#39;</span>
            <span class="c1"># So, extract the index from &#39;fnName&#39;.</span>
            <span class="c1"># condOutput = {&quot;variable&quot;: condName, &quot;index&quot;: 0}</span>
            <span class="n">condOutput</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">condName</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">fnName</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])}</span>

            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;condition&quot;</span><span class="p">,</span>
                <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">condName</span><span class="p">,</span>
                <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
                <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">}</span>
                    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                <span class="p">],</span>
            <span class="p">}</span>

            <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
                <span class="n">fnName</span><span class="p">,</span>
                <span class="n">condOutput</span><span class="p">,</span>
                <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">],</span>
                <span class="n">state</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

            <span class="n">body</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span>
                <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">condOutput</span><span class="p">,</span>
                <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">],</span>
            <span class="p">}</span>

            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
            <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span>
                <span class="n">fnName</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">],</span>
                <span class="n">state</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">lambdaStrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>
            <span class="n">startDefs</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ifDefs</span> <span class="o">=</span> <span class="n">startDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">elseDefs</span> <span class="o">=</span> <span class="n">startDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ifState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lastDefs</span><span class="o">=</span><span class="n">ifDefs</span><span class="p">)</span>
            <span class="n">elseState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lastDefs</span><span class="o">=</span><span class="n">elseDefs</span><span class="p">)</span>
            <span class="n">ifPgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">ifState</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>
            <span class="n">elsePgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">elseState</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>

            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">ifPgm</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">reduce</span><span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">elsePgm</span><span class="p">)</span>

            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">ifPgm</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">reduce</span><span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">elsePgm</span><span class="p">)</span>

            <span class="n">updatedDefs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">var</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">startDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">ifDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">elseDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">startDefs</span>
                <span class="ow">or</span> <span class="n">ifDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">startDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">elseDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">startDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="p">]</span>

            <span class="n">defVersions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">version</span>
                    <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="n">startDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                        <span class="n">ifDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                        <span class="n">elseDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">updatedDefs</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">updatedDef</span> <span class="ow">in</span> <span class="n">defVersions</span><span class="p">:</span>
                <span class="n">versions</span> <span class="o">=</span> <span class="n">defVersions</span><span class="p">[</span><span class="n">updatedDef</span><span class="p">]</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">condOutput</span><span class="p">,</span>
                        <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]},</span>
                        <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]},</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="k">else</span> <span class="p">[</span>
                        <span class="n">condOutput</span><span class="p">,</span>
                        <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]},</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                    <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">getNextDef</span><span class="p">(</span>
                        <span class="n">updatedDef</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">}</span>

                <span class="n">fnName</span> <span class="o">=</span> <span class="n">getFnName</span><span class="p">(</span>
                    <span class="n">fnNames</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.fnName}</span><span class="s2">__decision__</span><span class="si">{updatedDef}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">output</span>
                <span class="p">)</span>

                <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;decision&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                    <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
                    <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{var[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{var[&#39;index&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">}</span>
                        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span>
                    <span class="p">],</span>
                <span class="p">}</span>

                <span class="c1"># Check for buggy __decision__ tag containing of only IF_ blocks</span>
                <span class="c1"># More information required on how __decision__ tags are made</span>
                <span class="c1"># This seems to be in development phase and documentation is</span>
                <span class="c1"># missing from the GrFN spec as well. Actual removal (or not)</span>
                <span class="c1"># of this tag depends on further information about this</span>

                <span class="k">if</span> <span class="s2">&quot;IF_&quot;</span> <span class="ow">in</span> <span class="n">updatedDef</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s2">&quot;IF_&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]:</span>
                            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
                        <span class="k">continue</span>

                <span class="n">body</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">}</span>

                <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
                    <span class="n">fnName</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">state</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

                <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">fnName</span><span class="p">,</span>
                    <span class="n">updatedDef</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{src[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{src[&#39;index&#39;]}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span>
                    <span class="n">state</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lambdaStrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

            <span class="c1"># Previous ELIF Block is filled??</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">condSrcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;functions&quot;</span><span class="p">]:</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;body&quot;</span><span class="p">]:</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

                <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">condNum</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="n">condName</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;IF_</span><span class="si">{condNum}</span><span class="s2">&quot;</span>
                <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">[</span><span class="n">condName</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">[</span><span class="n">condName</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">fnName</span> <span class="o">=</span> <span class="n">getFnName</span><span class="p">(</span>
                    <span class="n">fnNames</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.fnName}</span><span class="s2">__condition__</span><span class="si">{condName}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{}</span>
                <span class="p">)</span>
                <span class="n">condOutput</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">condName</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">fnName</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])}</span>

                <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;condition&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">condName</span><span class="p">,</span>
                    <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                    <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">}</span>
                        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span>
                        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                    <span class="p">],</span>
                <span class="p">}</span>

                <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
                    <span class="n">fnName</span><span class="p">,</span>
                    <span class="n">condOutput</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">],</span>
                    <span class="n">state</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

                <span class="n">body</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span>
                    <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">condOutput</span><span class="p">,</span>
                    <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                    <span class="p">],</span>
                <span class="p">}</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

                <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="n">fnName</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span>
                        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                    <span class="p">],</span>
                    <span class="n">state</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lambdaStrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

                <span class="n">startDefs</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">ifDefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                <span class="n">elseDefs</span> <span class="o">=</span> <span class="n">startDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">updatedDefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

                <span class="n">defVersions</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">key</span><span class="p">:</span> <span class="p">[</span>
                        <span class="n">version</span>
                        <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="p">[</span>
                            <span class="n">startDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                            <span class="n">ifDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                            <span class="n">elseDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                        <span class="p">]</span>
                        <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">]</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">updatedDefs</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="n">updatedDef</span> <span class="ow">in</span> <span class="n">defVersions</span><span class="p">:</span>
                    <span class="n">versions</span> <span class="o">=</span> <span class="n">defVersions</span><span class="p">[</span><span class="n">updatedDef</span><span class="p">]</span>
                    <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">condOutput</span><span class="p">,</span>
                            <span class="p">{</span>
                                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                                <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="p">},</span>
                            <span class="p">{</span>
                                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                                <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                            <span class="p">},</span>
                        <span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                        <span class="k">else</span> <span class="p">[</span>
                            <span class="n">condOutput</span><span class="p">,</span>
                            <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]},</span>
                        <span class="p">]</span>
                    <span class="p">)</span>

                    <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                        <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">getNextDef</span><span class="p">(</span>
                            <span class="n">updatedDef</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span><span class="p">,</span>
                        <span class="p">),</span>
                    <span class="p">}</span>
                    <span class="n">fnName</span> <span class="o">=</span> <span class="n">getFnName</span><span class="p">(</span>
                        <span class="n">fnNames</span><span class="p">,</span>
                        <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.fnName}</span><span class="s2">__decision__</span><span class="si">{updatedDef}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">output</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span>
                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;decision&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                        <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                        <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="p">[</span>
                            <span class="p">{</span>
                                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{var[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{var[&#39;index&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                            <span class="p">}</span>
                            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span>
                        <span class="p">],</span>
                    <span class="p">}</span>

                    <span class="c1"># Check for buggy __decision__ tag containing of only</span>
                    <span class="c1"># IF_ blocks. More information required on how</span>
                    <span class="c1"># __decision__ tags are made.</span>
                    <span class="c1"># This seems to be in development phase and documentation is</span>
                    <span class="c1"># missing from the GrFN spec as well. Actual removal</span>
                    <span class="c1"># (or not) of this tag depends on further information</span>
                    <span class="c1"># about this</span>

                    <span class="k">if</span> <span class="s2">&quot;IF_&quot;</span> <span class="ow">in</span> <span class="n">updatedDef</span><span class="p">:</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="s2">&quot;IF_&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]:</span>
                                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
                            <span class="k">continue</span>

                    <span class="n">body</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span>
                        <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">,</span>
                        <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">,</span>
                    <span class="p">}</span>

                    <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
                        <span class="n">fnName</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">state</span>
                    <span class="p">)</span>

                    <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
                        <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

                    <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                        <span class="n">fnName</span><span class="p">,</span>
                        <span class="n">updatedDef</span><span class="p">,</span>
                        <span class="p">[</span>
                            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{src[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{src[&#39;index&#39;]}</span><span class="s2">&quot;</span>
                            <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">inputs</span>
                        <span class="p">],</span>
                        <span class="n">state</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">lambdaStrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">elif_pgm</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span>

        <span class="c1"># UnaryOp: (&#39;op&#39;, &#39;operand&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">UnaryOp</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;unaryop&quot;</span><span class="p">)</span>

        <span class="c1"># BinOp: (&#39;left&#39;, &#39;op&#39;, &#39;right&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">BINOPS</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">BINOPS</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)](</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                        <span class="k">return</span> <span class="p">[</span>
                            <span class="p">{</span>
                                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span>
                                <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">getDType</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
                                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                            <span class="p">}</span>
                        <span class="p">]</span>

            <span class="n">opPgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;binop&quot;</span>
            <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;binop&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">opPgm</span>

            <span class="k">return</span> <span class="n">opPgm</span>

        <span class="c1"># Mult: ()</span>

        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nodetype</span><span class="p">)</span> <span class="k">for</span> <span class="n">nodetype</span> <span class="ow">in</span> <span class="n">UNNECESSARY_TYPES</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Found </span><span class="si">{t}</span><span class="s2">, which should be unnecessary</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Expr: (&#39;value&#39;,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">):</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;expr&quot;</span><span class="p">)</span>
            <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
                    <span class="n">call</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
                    <span class="n">body</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">call</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">{},</span>
                        <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;file_\d+\.write&quot;</span><span class="p">,</span> <span class="n">body</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]):</span>
                        <span class="k">return</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">body</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span>
                                <span class="s2">&quot;Only 1 input per argument supported right now.&quot;</span>
                            <span class="p">)</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Unsupported expr: </span><span class="si">{expr}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span>

        <span class="c1"># Compare: (&#39;left&#39;, &#39;ops&#39;, &#39;comparators&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Compare</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;compare&quot;</span>
            <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">comparators</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;compare&quot;</span><span class="p">)</span>

        <span class="c1"># Subscript: (&#39;value&#39;, &#39;slice&#39;, &#39;ctx&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Subscript</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;can&#39;t handle arrays right now.&quot;</span><span class="p">)</span>

            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;subscript&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annassigned_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
                        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getNextDef</span><span class="p">(</span>
                            <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
                        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getNextDef</span><span class="p">(</span>
                            <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">annassigned_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annassigned_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">val</span>

        <span class="c1"># Name: (&#39;id&#39;, &#39;ctx&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;i_g_n_o_r_e___m_e__.*&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
                <span class="n">lastDef</span> <span class="o">=</span> <span class="n">getLastDef</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">,</span>
                                     <span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">call_source</span> <span class="o">!=</span> <span class="s2">&quot;annassign&quot;</span>
                <span class="p">):</span>
                    <span class="n">lastDef</span> <span class="o">=</span> <span class="n">getNextDef</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">nextDefs</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">lastDef</span><span class="p">}}]</span>

        <span class="c1"># AnnAssign: (&#39;target&#39;, &#39;annotation&#39;, &#39;value&#39;, &#39;simple&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AnnAssign</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">List</span><span class="p">):</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;annassign&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">getVarType</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">annotation</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annassigned_list</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">annassigned_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;annassign&quot;</span><span class="p">)</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;annassign&quot;</span><span class="p">)</span>

            <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">getVarType</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">annotation</span>
                <span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">getFnName</span><span class="p">(</span>
                    <span class="n">fnNames</span><span class="p">,</span>
                    <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.fnName}</span><span class="s2">__assign__</span><span class="si">{target[&#39;var&#39;][&#39;variable&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">{},</span>
                <span class="p">)</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_fn_dict</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_body_dict</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                        <span class="n">node</span><span class="p">,</span>
                        <span class="n">name</span><span class="p">,</span>
                        <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                        <span class="p">[</span>
                            <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span>
                            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                        <span class="p">],</span>
                        <span class="n">state</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">lambdaStrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

                <span class="c1"># In the case of assignments of the form: &quot;ud: List[float]&quot;</span>
                <span class="c1"># an assignment function will be created with an empty input</span>
                <span class="c1"># list. Also, the function dictionary will be empty. We do</span>
                <span class="c1"># not want such assignments in the GrFN so check for an empty</span>
                <span class="c1"># &lt;fn&gt; dictionary and return [] if found</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;sources&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;dtype&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{sources[0][&#39;value&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">}</span>

                <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span>

        <span class="c1"># Assign: (&#39;targets&#39;, &#39;value&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Assign</span><span class="p">):</span>

            <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span> <span class="o">=</span> <span class="n">scope_path</span>

            <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;assign&quot;</span><span class="p">)</span>

            <span class="n">targets</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;assign&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span>
                <span class="p">],</span>
            <span class="p">)</span>

            <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;list&quot;</span><span class="p">):</span>
                    <span class="n">targets</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;list&quot;</span><span class="p">]]</span>
                    <span class="p">)</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">targets</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>

                <span class="c1"># Check whether this is an alias assignment i.e. of the form</span>
                <span class="c1"># y=x where y is now the alias of variable x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">check_alias</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">)</span>

                <span class="c1"># state.varTypes[target[&quot;var&quot;][&quot;variable&quot;]] = getVarType(</span>
                <span class="c1">#     node.annotation)</span>

                <span class="n">name</span> <span class="o">=</span> <span class="n">getFnName</span><span class="p">(</span>
                    <span class="n">fnNames</span><span class="p">,</span>
                    <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.fnName}</span><span class="s2">__assign__</span><span class="si">{target[&#39;var&#39;][&#39;variable&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">target</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_fn_dict</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_body_dict</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

                <span class="n">source_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_source_list_dict</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>

                <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span> <span class="n">source_list</span><span class="p">,</span> <span class="n">state</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lambdaStrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;sources&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;list&quot;</span><span class="p">):</span>
                        <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;list&quot;</span><span class="p">]:</span>
                            <span class="n">dtypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">])</span>
                            <span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;call&quot;</span><span class="p">)</span> <span class="ow">and</span> \
                            <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Float32&quot;</span><span class="p">:</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{sources[0][&#39;call&#39;][&#39;inputs&#39;][0][0][&#39;value&#39;]}</span><span class="s2">&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{sources[0][&#39;value&#39;]}</span><span class="s2">&quot;</span>
                    <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span>
                        <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span>
                    <span class="p">}</span>

                <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span>

        <span class="c1"># Tuple: (&#39;elts&#39;, &#39;ctx&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Tuple</span><span class="p">):</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">elmt</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;ctx&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">elmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span>
            <span class="p">]:</span>
                <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">elements</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[{</span><span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="n">elements</span><span class="p">}]</span>

        <span class="c1"># Call: (&#39;func&#39;, &#39;args&#39;, &#39;keywords&#39;)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
                <span class="c1"># Check if there is a &lt;sys&gt; call. Bypass it if exists.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="s2">&quot;sys&quot;</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[]</span>
                <span class="n">fnNode</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">fnNode</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
                <span class="n">fnName</span> <span class="o">=</span> <span class="n">fnNode</span><span class="o">.</span><span class="n">attr</span>
                <span class="n">fnName</span> <span class="o">=</span> <span class="n">module</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">fnName</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fnName</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;call&quot;</span><span class="p">)</span>
                <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="n">call</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;call&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">fnName</span><span class="p">,</span> <span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">}}</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">call</span><span class="p">]</span>

        <span class="c1"># Module: body</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
            <span class="n">pgms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cur</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="n">pgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">)</span>
                <span class="n">pgms</span> <span class="o">+=</span> <span class="n">pgm</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mergeDicts</span><span class="p">(</span><span class="n">pgms</span><span class="p">)]</span>

        <span class="c1"># BoolOp: body</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">BoolOp</span><span class="p">):</span>
            <span class="n">pgms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">boolOp</span> <span class="o">=</span> <span class="p">{</span><span class="n">ast</span><span class="o">.</span><span class="n">And</span><span class="p">:</span> <span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Or</span><span class="p">:</span> <span class="s2">&quot;or&quot;</span><span class="p">}</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">boolOp</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                    <span class="n">pgms</span><span class="o">.</span><span class="n">append</span><span class="p">([{</span><span class="s2">&quot;boolOp&quot;</span><span class="p">:</span> <span class="n">boolOp</span><span class="p">[</span><span class="n">key</span><span class="p">]}])</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">pgms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="s2">&quot;boolop&quot;</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">pgms</span>

        <span class="c1"># Handle Attributes</span>
        <span class="c1"># This is a fix on `feature_save` branch to bypass the SAVE statement</span>
        <span class="c1"># feature where a SAVEd variable is referenced as</span>
        <span class="c1"># &lt;function_name&gt;.&lt;variable_name&gt;. So the code below only returns the</span>
        <span class="c1"># &lt;variable_name&gt; which is stored under `node.attr`. The `node.id`</span>
        <span class="c1"># stores the &lt;function_name&gt; which is being ignored.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
            <span class="c1"># When a computations float value is extracted using the Float32</span>
            <span class="c1"># class&#39;s _val method, an ast.Attribute will be present, just</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_val&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fnNames</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lastDef</span> <span class="o">=</span> <span class="n">getLastDef</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">lastDefs</span><span class="p">,</span>
                                     <span class="n">state</span><span class="o">.</span><span class="n">lastDefDefault</span><span class="p">)</span>

                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">lastDef</span><span class="p">}}]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AST</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;No handler for AST.</span><span class="si">{node.__class__.__name__}</span><span class="s2"> in genPgm, &quot;</span>
                <span class="n">f</span><span class="s2">&quot;fields: </span><span class="si">{node._fields}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;No handler for </span><span class="si">{node.__class__.__name__}</span><span class="s2"> in genPgm, &quot;</span>
                <span class="n">f</span><span class="s2">&quot;value: {str(node)}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">[]</span></div>

    <span class="c1"># This function checks whether an assignment is an alias created. An alias</span>
    <span class="c1"># is created when an assignment of the form y=x happens such that y is now</span>
    <span class="c1"># an alias of x because it is an exact copy of x. If it is an alias</span>
    <span class="c1"># assignment, the dictionary alias_dict will get populated.</span>

<div class="viewcode-block" id="GrFNGenerator.check_alias"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.check_alias">[docs]</a>    <span class="k">def</span> <span class="nf">check_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">):</span>
        <span class="n">target_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_index</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alias_dict</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alias_dict</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
                <span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_iden_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_iden_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_iden_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="n">holder</span><span class="p">):</span>
        <span class="c1"># Check for aliases</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">aliases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">targets</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">targets</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span> <span class="s2">&quot;None&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">aliases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">)</span>

        <span class="c1"># First, check whether the information is from a variable or a</span>
        <span class="c1"># holder(assign, loop, if, etc). Assign the base_name accordingly</span>

        <span class="k">if</span> <span class="n">holder</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
            <span class="c1"># If we are making the identifier specification of a body holder,</span>
            <span class="c1"># the base_name will be the holder</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">base_name</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">name</span>
                    <span class="o">+</span> <span class="s2">&quot;$&quot;</span>
                    <span class="o">+</span> <span class="n">targets</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">targets</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">base_name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">targets</span>
            <span class="n">gensyms_tag</span> <span class="o">=</span> <span class="s2">&quot;h&quot;</span>

        <span class="k">elif</span> <span class="n">holder</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span><span class="p">:</span>
            <span class="c1"># The base name will just be the name of the identifier</span>
            <span class="n">base_name</span> <span class="o">=</span> <span class="n">targets</span>
            <span class="n">gensyms_tag</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span>

        <span class="c1"># The name space should get the entire directory scope of the fortran</span>
        <span class="c1"># file under which it is defined. For PETASCE.for, all modules are</span>
        <span class="c1"># defined in the same fortran file so the namespace will be the same</span>
        <span class="c1"># for all identifiers</span>

        <span class="c1"># TODO handle multiple file namespaces that handle multiple fortran</span>
        <span class="c1"># file namespacing</span>

        <span class="c1"># TODO Is the namespace path for the python intermediates or the</span>
        <span class="c1"># original FORTRAN code? Currently, it captures the intermediate</span>
        <span class="c1"># python file&#39;s path</span>
        <span class="n">name_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;FileName&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
        <span class="n">name_space</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name_space</span><span class="p">)</span>

        <span class="c1"># The scope captures the scope within the file where it exists. The</span>
        <span class="c1"># context of modules can be implemented here.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">scope_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;_TOP&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span>

        <span class="c1"># TODO Source code reference: This is the line number in the Python</span>
        <span class="c1"># (or FORTRAN?) file. According to meeting on the 21st Feb, 2019,</span>
        <span class="c1"># this was the same as namespace. Exactly same though? Need clarity.</span>

        <span class="n">source_reference</span> <span class="o">=</span> <span class="n">name_space</span>

        <span class="n">iden_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;base_name&quot;</span><span class="p">:</span> <span class="n">base_name</span><span class="p">,</span>
            <span class="s2">&quot;scope&quot;</span><span class="p">:</span> <span class="n">scope_path</span><span class="p">,</span>
            <span class="s2">&quot;namespace&quot;</span><span class="p">:</span> <span class="n">name_space</span><span class="p">,</span>
            <span class="s2">&quot;aliases&quot;</span><span class="p">:</span> <span class="n">aliases</span><span class="p">,</span>
            <span class="s2">&quot;source_references&quot;</span><span class="p">:</span> <span class="n">source_reference</span><span class="p">,</span>
            <span class="s2">&quot;gensyms&quot;</span><span class="p">:</span> <span class="n">generage_gensysm</span><span class="p">(</span><span class="n">gensyms_tag</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">iden_dict</span></div>

    <span class="c1"># Create the identifier specification for each identifier</span>
<div class="viewcode-block" id="GrFNGenerator.make_identifier_spec"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_identifier_spec">[docs]</a>    <span class="k">def</span> <span class="nf">make_identifier_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span>
        <span class="n">for_id</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">if_id</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">identifier_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">scope</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scope_path</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">scope</span> <span class="o">==</span> <span class="s2">&quot;loop&quot;</span><span class="p">:</span>
                <span class="n">scope_path</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">for_id</span><span class="p">)</span>
                <span class="n">for_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">scope</span> <span class="o">==</span> <span class="s2">&quot;if&quot;</span><span class="p">:</span>
                <span class="n">scope_path</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">for_id</span><span class="p">)</span>
                <span class="n">if_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Identify which kind of identifier it is</span>
        <span class="n">name_regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?P&lt;scope&gt;\w+)__(?P&lt;type&gt;\w+)__(?P&lt;basename&gt;\w+)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name_regex</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;assign&quot;</span><span class="p">:</span>
                <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span>
                <span class="p">)</span>
                <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                        <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span>
                            <span class="n">scope_path</span><span class="p">,</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;condition&quot;</span><span class="p">:</span>
                <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span>
                <span class="p">)</span>
                <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                        <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span>
                            <span class="n">scope_path</span><span class="p">,</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;loop_plate&quot;</span><span class="p">:</span>
                <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span>
                <span class="p">)</span>
                <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                        <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span>
                            <span class="n">scope_path</span><span class="p">,</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;decision&quot;</span><span class="p">:</span>
                <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span>
                <span class="p">)</span>
                <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                        <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span>
                            <span class="n">scope_path</span><span class="p">,</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">identifier_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_body_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_body_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_body_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_call_index_dict</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>

        <span class="c1"># Removing duplicates</span>
        <span class="n">unique_source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="p">[</span><span class="n">unique_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">source_list</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span>
         <span class="n">unique_source</span><span class="p">]</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="n">unique_source</span>

        <span class="n">id_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">],</span> <span class="n">source_list</span><span class="p">,</span> <span class="n">state</span>
        <span class="p">)</span>

        <span class="n">body</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">],</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">source_list</span><span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">body</span><span class="p">,</span> <span class="n">id_spec</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_call_index_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_call_index_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_call_index_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">source</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_call_index_dict</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">source_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_source_list_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_source_list_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_source_list_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sourceDict</span><span class="p">):</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sourceDict</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_source_list_dict</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>

        <span class="c1"># Removing duplicates</span>
        <span class="n">unique_source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="p">[</span><span class="n">unique_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">source_list</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span>
         <span class="n">unique_source</span><span class="p">]</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="n">unique_source</span>

        <span class="k">return</span> <span class="n">source_list</span></div>


<div class="viewcode-block" id="GrFNGenerator.make_fn_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_fn_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_fn_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Preprocessing and removing certain Assigns which only pertain to the</span>
        <span class="c1"># Python code and do not relate to the FORTRAN code in any way.</span>
        <span class="n">bypass_match_target</span> <span class="o">=</span> <span class="n">RE_BYPASS_IO</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span> <span class="s2">&quot;variable&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">bypass_match_target</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">fn</span>

        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="c1"># Bypassing identifiers who have I/O constructs on their source</span>
                <span class="c1"># fields too.s</span>
                <span class="c1"># Example: (i[0],) = format_10_obj.read_line(file_10.readline())</span>
                <span class="c1"># &#39;i&#39; is bypassed here</span>
                <span class="c1"># TODO this is only for PETASCE02.for. Will need to include &#39;i&#39;</span>
                <span class="c1">#  in the long run</span>
                <span class="n">bypass_match_source</span> <span class="o">=</span> <span class="n">RE_BYPASS_IO</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span>
                                                              <span class="s2">&quot;function&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">bypass_match_source</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">fn</span>
                <span class="k">for</span> <span class="n">source_ins</span> <span class="ow">in</span> <span class="n">make_call_body_dict</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
                    <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_ins</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">})</span>

            <span class="c1"># Removing duplicates</span>
            <span class="n">unique_source</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="p">[</span><span class="n">unique_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">source</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span>
             <span class="n">unique_source</span><span class="p">]</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">unique_source</span>

            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="s2">&quot;list&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="c1"># This is a write to a file</span>
                <span class="k">return</span> <span class="n">fn</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;assign&quot;</span><span class="p">,</span>
                <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="n">source</span><span class="p">,</span>
                <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">fn</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_decorators"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_decorators">[docs]</a>    <span class="k">def</span> <span class="nf">process_decorators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Go through each decorator and extract relevant information.</span>
<span class="sd">            Currently this function only checks for the static_vars decorator</span>
<span class="sd">            for the SAVEd variables and updates varTypes with the data types</span>
<span class="sd">            of each variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">decorator</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="n">decorator</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="n">function_name</span> <span class="o">==</span> <span class="s2">&quot;static_vars&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">decorator</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">:</span>
                    <span class="n">variable</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">s</span>
                    <span class="nb">type</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">s</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">REVERSE_ANNOTATE_MAP</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="PGMState"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.PGMState">[docs]</a><span class="k">class</span> <span class="nc">PGMState</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lambdaStrings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">lastDefs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">nextDefs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">lastDefDefault</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">fnName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">varTypes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">scope_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lastDefs</span> <span class="o">=</span> <span class="n">lastDefs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nextDefs</span> <span class="o">=</span> <span class="n">nextDefs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lastDefDefault</span> <span class="o">=</span> <span class="n">lastDefDefault</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fnName</span> <span class="o">=</span> <span class="n">fnName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varTypes</span> <span class="o">=</span> <span class="n">varTypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_path</span> <span class="o">=</span> <span class="n">scope_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambdaStrings</span> <span class="o">=</span> <span class="n">lambdaStrings</span>

<div class="viewcode-block" id="PGMState.copy"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.PGMState.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lastDefs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nextDefs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lastDefDefault</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fnName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">varTypes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scope_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lambdaStrings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">PGMState</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambdaStrings</span> <span class="k">if</span> <span class="n">lambdaStrings</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lambdaStrings</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lastDefs</span> <span class="k">if</span> <span class="n">lastDefs</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lastDefs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nextDefs</span> <span class="k">if</span> <span class="n">nextDefs</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nextDefs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lastDefDefault</span> <span class="k">if</span> <span class="n">lastDefDefault</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lastDefDefault</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fnName</span> <span class="k">if</span> <span class="n">fnName</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">fnName</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">varTypes</span> <span class="k">if</span> <span class="n">varTypes</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">varTypes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scope_path</span> <span class="k">if</span> <span class="n">scope_path</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scope_path</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="dump"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.dump">[docs]</a><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">annotate_fields</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s2">&quot;  &quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a formatted dump of the tree in *node*.  This is mainly useful for</span>
<span class="sd">    debugging purposes.  The returned string will show the names and the values</span>
<span class="sd">    for fields.  This makes the code impossible to evaluate, so if evaluation</span>
<span class="sd">    is wanted *annotate_fields* must be set to False. Attributes such as line</span>
<span class="sd">    numbers and column offsets are not dumped by default. If this is wanted,</span>
<span class="sd">    *include_attributes* can be set to True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AST</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">_format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ast</span><span class="o">.</span><span class="n">iter_fields</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">include_attributes</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
                <span class="n">fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_format</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">level</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_attributes</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="s2">&quot;(&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">field</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">annotate_fields</span>
                        <span class="k">else</span> <span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;[&quot;</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">indent</span> <span class="o">*</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">_format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">*</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;]&quot;</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AST</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected AST, got </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_format</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>


<div class="viewcode-block" id="printPgm"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.printPgm">[docs]</a><span class="k">def</span> <span class="nf">printPgm</span><span class="p">(</span><span class="n">pgmFile</span><span class="p">,</span> <span class="n">pgm</span><span class="p">):</span>
    <span class="n">pgmFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pgm</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="genFn"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.genFn">[docs]</a><span class="k">def</span> <span class="nf">genFn</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">fnName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">returnVal</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="n">lambda_strings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">argument_strings</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Sort the arguments in the function call as it is used in the operation</span>
    <span class="n">input_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inputs</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Add type annotations to the function arguments</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">input_list</span><span class="p">:</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">annotation</span><span class="p">:</span>
            <span class="c1"># varTypes does not contain annotations for variables for indexing</span>
            <span class="c1"># such as &#39;abc_1&#39;, etc. Check if the such variables exist and</span>
            <span class="c1"># assign appropriate annotations</span>
            <span class="n">key_match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">var</span><span class="p">,</span> <span class="n">dicn</span><span class="p">:</span> <span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dicn</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">var</span><span class="p">])</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">[</span><span class="n">key_match</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">varTypes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">ANNOTATE_MAP</span><span class="p">[</span><span class="n">annotation</span><span class="p">]</span>
        <span class="n">argument_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{ip}</span><span class="s2">: </span><span class="si">{annotation}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">f</span><span class="s2">&quot;def </span><span class="si">{fnName}</span><span class="s2">({&#39;, &#39;.join(argument_strings)}):</span><span class="se">\n</span><span class="s2">    &quot;</span>
    <span class="p">)</span>
    <span class="c1"># If a `decision` tag comes up, override the call to genCode to manually</span>
    <span class="c1"># enter the python script for the lambda file.</span>
    <span class="k">if</span> <span class="s2">&quot;__decision__&quot;</span> <span class="ow">in</span> <span class="n">fnName</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{inputs[2]}</span><span class="s2"> if </span><span class="si">{inputs[0]}</span><span class="s2"> else </span><span class="si">{inputs[1]}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">genCode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">PrintState</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">returnVal</span><span class="p">:</span>
        <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;return </span><span class="si">{code}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;[^ ]&quot;</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="n">indent</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;return &quot;</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">indent</span><span class="p">:]</span>
        <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
    <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lambda_strings</span><span class="p">)</span></div>


<div class="viewcode-block" id="mergeDicts"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.mergeDicts">[docs]</a><span class="k">def</span> <span class="nf">mergeDicts</span><span class="p">(</span><span class="n">dicts</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">))</span>

    <span class="n">merged_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">dicts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">merged_dict</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_dict</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">merged_dict</span></div>


<div class="viewcode-block" id="getFnName"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.getFnName">[docs]</a><span class="k">def</span> <span class="nf">getFnName</span><span class="p">(</span><span class="n">fnNames</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="c1"># First, check whether the basename is a &#39;decision&#39; block. If it is, we</span>
    <span class="c1"># need to get it&#39;s index from the index of its corresponding identifier&#39;s</span>
    <span class="c1"># &#39;assign&#39; block. We do not use the index of the &#39;decision&#39; block as that</span>
    <span class="c1"># will not correspond with that of the &#39;assign&#39; block.  For example: for</span>
    <span class="c1"># petpt__decision__albedo, its index will be the index of the latest</span>
    <span class="c1"># petpt__assign__albedo + 1</span>

    <span class="k">if</span> <span class="s2">&quot;__decision__&quot;</span> <span class="ow">in</span> <span class="n">basename</span><span class="p">:</span>
        <span class="n">part_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;(?P&lt;body&gt;\S+)__decision__(?P&lt;identifier&gt;\S+)&quot;</span><span class="p">,</span> <span class="n">basename</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">part_match</span><span class="p">:</span>
            <span class="n">new_basename</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">part_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;__assign__&quot;</span>
                <span class="o">+</span> <span class="n">part_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;identifier&quot;</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_basename</span> <span class="o">=</span> <span class="n">basename</span>
    <span class="n">fnId</span> <span class="o">=</span> <span class="n">fnNames</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_basename</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">):</span>
            <span class="n">fnId</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">target</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">):</span>
            <span class="n">fnId</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fnId</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fnId</span> <span class="o">=</span> <span class="n">fnNames</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_basename</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">fnName</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{basename}</span><span class="s2">_</span><span class="si">{fnId}</span><span class="s2">&quot;</span>
    <span class="n">fnNames</span><span class="p">[</span><span class="n">basename</span><span class="p">]</span> <span class="o">=</span> <span class="n">fnId</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">fnName</span></div>


<div class="viewcode-block" id="getLastDef"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.getLastDef">[docs]</a><span class="k">def</span> <span class="nf">getLastDef</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">lastDefs</span><span class="p">,</span> <span class="n">lastDefDefault</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">lastDefDefault</span>

    <span class="c1"># Preprocessing and removing certain Assigns which only pertain to the</span>
    <span class="c1"># Python code and do not relate to the FORTRAN code in any way.</span>
    <span class="n">bypass_match</span> <span class="o">=</span> <span class="n">RE_BYPASS_IO</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">bypass_match</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">lastDefs</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">lastDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lastDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="getNextDef"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.getNextDef">[docs]</a><span class="k">def</span> <span class="nf">getNextDef</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">lastDefs</span><span class="p">,</span> <span class="n">nextDefs</span><span class="p">,</span> <span class="n">lastDefDefault</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">nextDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">lastDefDefault</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nextDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">lastDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">return</span> <span class="n">index</span></div>


<div class="viewcode-block" id="getVarType"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.getVarType">[docs]</a><span class="k">def</span> <span class="nf">getVarType</span><span class="p">(</span><span class="n">annNode</span><span class="p">):</span>
    <span class="c1"># wrapped in list</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annNode</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Subscript</span><span class="p">):</span>
        <span class="n">dType</span> <span class="o">=</span> <span class="n">annNode</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dType</span> <span class="o">=</span> <span class="n">annNode</span><span class="o">.</span><span class="n">id</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">REVERSE_ANNOTATE_MAP</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">REVERSE_ANNOTATE_MAP</span><span class="p">[</span><span class="n">dType</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;Unsupported type (only float, int, list, and str &quot;</span>
                <span class="s2">&quot;supported as of now).</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Unsupported type (annNode is None).&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="getDType"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.getDType">[docs]</a><span class="k">def</span> <span class="nf">getDType</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;integer&quot;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;real&quot;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;num: {type(val)}.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dtype</span></div>


<div class="viewcode-block" id="get_body_and_functions"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_body_and_functions">[docs]</a><span class="k">def</span> <span class="nf">get_body_and_functions</span><span class="p">(</span><span class="n">pgm</span><span class="p">):</span>
    <span class="n">body</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">pgm</span><span class="p">))</span>
    <span class="n">fns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">pgm</span><span class="p">))</span>
    <span class="n">iden_spec</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">pgm</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">body</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">iden_spec</span></div>


<div class="viewcode-block" id="generage_gensysm"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.generage_gensysm">[docs]</a><span class="k">def</span> <span class="nf">generage_gensysm</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>

    <span class="c1"># The gensym is used to uniquely identify any identifier in the program.</span>
    <span class="c1"># Python&#39;s uuid library is used to generate a unique 12 digit HEX string.</span>
    <span class="c1"># The uuid4() function of &#39;uuid&#39; focuses on randomness. Each and every bit</span>
    <span class="c1"># of a UUID v4 is generated randomly and with no inherent logic. To every</span>
    <span class="c1"># gensym, we add a tag signifying the data type it represents. &#39;v&#39; is for</span>
    <span class="c1"># variables and &#39;h&#39; is for holders.</span>


    <span class="k">return</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span><span class="p">[:</span><span class="mi">12</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">tag</span></div>


<div class="viewcode-block" id="make_call_body_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.make_call_body_dict">[docs]</a><span class="k">def</span> <span class="nf">make_call_body_dict</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
    <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># We are going to remove addition of functions such as &quot;max&quot;, &quot;exp&quot;,</span>
    <span class="c1"># &quot;sin&quot;, \etc to the source list. The following two lines when commented</span>
    <span class="c1"># helps us do that. If user-defined functions come up as sources,</span>
    <span class="c1"># some other approaches might be required</span>
    <span class="c1"># TODO Try with user defined functions and see if the below two lines need</span>
    <span class="c1">#  to be reworked</span>
    <span class="c1"># name = source[&quot;call&quot;][&quot;function&quot;]</span>
    <span class="c1"># source_list.append({&quot;name&quot;: name, &quot;type&quot;: &quot;function&quot;})</span>

    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">source</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                    <span class="n">variable</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">})</span>
                <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                    <span class="c1"># TODO Do repetitions in this like in the above check need</span>
                    <span class="c1">#  to be removed?</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">],</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">}</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">make_call_body_dict</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">source_list</span></div>


<div class="viewcode-block" id="importAst"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.importAst">[docs]</a><span class="k">def</span> <span class="nf">importAst</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokenize</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span></div>


<span class="c1"># Get the absolute path of the python files whose PGMs are being generated.</span>
<span class="c1"># TODO: For now the path is started from the directory &quot;for2py&quot; but need further</span>
<span class="c1"># discussion on this</span>


<div class="viewcode-block" id="get_path"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_path">[docs]</a><span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="n">fileName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">absPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">instance</span> <span class="o">==</span> <span class="s2">&quot;namespace&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*\/(for2py\/.*).py$&quot;</span><span class="p">,</span> <span class="n">absPath</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*\/(for2py\/.*).py$&quot;</span><span class="p">,</span> <span class="n">absPath</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fileName</span>
    <span class="k">elif</span> <span class="n">instance</span> <span class="o">==</span> <span class="s2">&quot;source&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*\/(for2py\/.*$)&quot;</span><span class="p">,</span> <span class="n">absPath</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*\/(for2py\/.*$)&quot;</span><span class="p">,</span> <span class="n">absPath</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fileName</span></div>


<div class="viewcode-block" id="create_pgm_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.create_pgm_dict">[docs]</a><span class="k">def</span> <span class="nf">create_pgm_dict</span><span class="p">(</span>
    <span class="n">lambdaFile</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">asts</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
    <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">mode_mapper_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">save_file</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Create a Python dict representing the PGM, with additional metadata for</span>
<span class="sd">    JSON output. &quot;&quot;&quot;</span>

    <span class="n">lambdaStrings</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;from numbers import Real</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;import delphi.translators.for2py.math_ext as math</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="p">]</span>

    <span class="n">state</span> <span class="o">=</span> <span class="n">PGMState</span><span class="p">(</span><span class="n">lambdaStrings</span><span class="p">)</span>
    <span class="n">generator</span> <span class="o">=</span> <span class="n">GrFNGenerator</span><span class="p">()</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">mode_mapper</span> <span class="o">=</span> <span class="n">mode_mapper_dict</span>
    <span class="n">pgm</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">genPgm</span><span class="p">(</span><span class="n">asts</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="p">{},</span> <span class="s2">&quot;&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">pgm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">):</span>
        <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">function_defs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">get_path</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">)]]</span>

    <span class="c1"># dateCreated stores the date and time on which the lambda and PGM file</span>
    <span class="c1"># was created. It is stored in YYYMMDD format</span>
    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;dateCreated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;{datetime.today().strftime(&#39;%Y%m</span><span class="si">%d</span><span class="s2">&#39;)}&quot;</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">lambdaFile</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lambdaStrings</span><span class="p">))</span>

    <span class="c1"># View the PGM file that will be used to build a scope tree</span>
    <span class="k">if</span> <span class="n">save_file</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">pgm</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">[:</span><span class="n">file_name</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)]</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">pgm</span></div>


<div class="viewcode-block" id="get_asts_from_files"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_asts_from_files">[docs]</a><span class="k">def</span> <span class="nf">get_asts_from_files</span><span class="p">(</span><span class="n">files</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">printAst</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">asts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">asts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">importAst</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">printAst</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">asts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">asts</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-f&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--files&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A list of python files to generate a PGM for&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-p&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--PGMFile&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Filename for the output PGM&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-l&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--lambdaFile&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Filename for output lambda functions&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-o&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--out&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Text file containing the list of output python files being &quot;</span>
             <span class="s2">&quot;generated&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-a&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--printAst&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Print ASTs&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pythonFiles</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">pythonFileList</span> <span class="o">=</span> <span class="n">pythonFiles</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="n">asts</span> <span class="o">=</span> <span class="n">get_asts_from_files</span><span class="p">(</span><span class="n">pythonFileList</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">printAst</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">inAst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">asts</span><span class="p">):</span>
        <span class="c1"># Read the mode_gen file containing all the identifier mappings</span>
        <span class="n">mode_mapperDict</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">pythonFileList</span><span class="p">[</span><span class="n">index</span><span class="p">][:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.xml&quot;</span><span class="p">)</span>

        <span class="n">lambdaFile</span> <span class="o">=</span> <span class="n">pythonFileList</span><span class="p">[</span><span class="n">index</span><span class="p">][:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">args</span><span class="o">.</span><span class="n">lambdaFile</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pgmFile</span> <span class="o">=</span> <span class="n">pythonFileList</span><span class="p">[</span><span class="n">index</span><span class="p">][:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">args</span><span class="o">.</span><span class="n">PGMFile</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pgm_dict</span> <span class="o">=</span> <span class="n">create_pgm_dict</span><span class="p">(</span>
            <span class="n">lambdaFile</span><span class="p">,</span> <span class="p">[</span><span class="n">inAst</span><span class="p">],</span> <span class="n">pythonFileList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">mode_mapperDict</span>
        <span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pgmFile</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">printPgm</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pgm_dict</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Adarsh

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>