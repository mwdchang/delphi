

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>delphi.GrFN.networks &mdash; delphi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script type="text/javascript" src="../../../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> delphi
          

          
            
            <img src="../../../_static/delphi_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../AnalysisGraph_API.html">AnalysisGraph API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../grfn_spec.html">Grounded Function Network (GrFN) JSON Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../grfn_spec.html#change-log">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cpp_api/library_root.html">C++ API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">delphi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>delphi.GrFN.networks</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for delphi.GrFN.networks</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">subprocess</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">SALib.analyze</span> <span class="k">import</span> <span class="n">sobol</span><span class="p">,</span> <span class="n">fast</span><span class="p">,</span> <span class="n">rbd_fast</span>
<span class="kn">from</span> <span class="nn">SALib.sample</span> <span class="k">import</span> <span class="n">saltelli</span><span class="p">,</span> <span class="n">fast_sampler</span><span class="p">,</span> <span class="n">latin</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.algorithms.simple_paths</span> <span class="k">import</span> <span class="n">all_simple_paths</span>

<span class="kn">from</span> <span class="nn">delphi.translators.for2py.types_ext</span> <span class="k">import</span> <span class="n">Float32</span>
<span class="kn">from</span> <span class="nn">delphi.GrFN.analysis</span> <span class="k">import</span> <span class="n">get_max_s2_sensitivity</span>
<span class="kn">import</span> <span class="nn">delphi.GrFN.utils</span> <span class="k">as</span> <span class="nn">utils</span>
<span class="kn">from</span> <span class="nn">delphi.GrFN.utils</span> <span class="k">import</span> <span class="n">ScopeNode</span>
<span class="kn">from</span> <span class="nn">delphi.utils.misc</span> <span class="k">import</span> <span class="n">choose_font</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">genPGM</span><span class="p">,</span>
    <span class="n">f2grfn</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="n">FONT</span> <span class="o">=</span> <span class="n">choose_font</span><span class="p">()</span>

<span class="n">dodgerblue3</span> <span class="o">=</span> <span class="s2">&quot;#1874CD&quot;</span>
<span class="n">forestgreen</span> <span class="o">=</span> <span class="s2">&quot;#228b22&quot;</span>


<div class="viewcode-block" id="ComputationalGraph"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.ComputationalGraph">[docs]</a><span class="k">class</span> <span class="nc">ComputationalGraph</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">n</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">]</span>

<div class="viewcode-block" id="ComputationalGraph.build_call_graph"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.ComputationalGraph.build_call_graph">[docs]</a>    <span class="k">def</span> <span class="nf">build_call_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">predecessor_variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">predecessor_function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span>
                        <span class="n">predecessor_variable</span>
                    <span class="p">):</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">predecessor_function</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="ComputationalGraph.build_function_sets"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.ComputationalGraph.build_function_sets">[docs]</a>    <span class="k">def</span> <span class="nf">build_function_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO - this fails when there is only one function node in the graph -</span>
        <span class="c1"># need to fix!</span>
        <span class="n">initial_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_graph</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">find_distances</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
            <span class="n">all_successors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">func</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>
                <span class="n">all_successors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">call_graph</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_successors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">find_distances</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_successors</span><span class="p">)),</span> <span class="n">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">find_distances</span><span class="p">(</span><span class="n">initial_funcs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">call_sets</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">call_dist</span> <span class="ow">in</span> <span class="n">distances</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">call_dist</span> <span class="ow">in</span> <span class="n">call_sets</span><span class="p">:</span>
                <span class="n">call_sets</span><span class="p">[</span><span class="n">call_dist</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">func_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">call_sets</span><span class="p">[</span><span class="n">call_dist</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">func_name</span><span class="p">}</span>

        <span class="n">function_set_dists</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">call_sets</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="p">)</span>
        <span class="n">function_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">func_set</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">func_set</span> <span class="ow">in</span> <span class="n">function_set_dists</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">function_sets</span></div>

<div class="viewcode-block" id="ComputationalGraph.run"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.ComputationalGraph.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]],</span>
        <span class="n">torch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Executes the GrFN over a particular set of inputs and returns the</span>
<span class="sd">        result.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: Input set where keys are the names of input nodes in the</span>
<span class="sd">                GrFN and each key points to a set of input values (or just one).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A set of outputs from executing the GrFN, one for every set of</span>
<span class="sd">            inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set input values</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">Float32</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">func_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_sets</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="n">func_set</span><span class="p">:</span>
                <span class="n">lambda_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">func_name</span><span class="p">][</span><span class="s2">&quot;lambda_fn&quot;</span><span class="p">]</span>
                <span class="n">output_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">func_name</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">func_name</span><span class="p">][</span><span class="s2">&quot;func_inputs&quot;</span><span class="p">]</span>
                <span class="n">input_values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">]</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">lambda_fn</span><span class="p">(</span><span class="o">*</span><span class="n">input_values</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">Float32</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">torch_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">output_node</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">*</span> <span class="n">torch_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">output_node</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>

        <span class="c1"># Return the output</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">output_node</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="ComputationalGraph.to_CAG"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.ComputationalGraph.to_CAG">[docs]</a>    <span class="k">def</span> <span class="nf">to_CAG</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Export to a Causal Analysis Graph (CAG) PyGraphviz AGraph object.</span>
<span class="sd">        The CAG shows the influence relationships between the variables and</span>
<span class="sd">        elides the function nodes.&quot;&quot;&quot;</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pred_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
                        <span class="n">fn_type</span> <span class="ow">in</span> <span class="n">pred_fn</span>
                        <span class="k">for</span> <span class="n">fn_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;condition&quot;</span><span class="p">,</span> <span class="s2">&quot;decision&quot;</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="k">for</span> <span class="n">pred_var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">pred_fn</span><span class="p">):</span>
                            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">pred_var</span><span class="p">][</span><span class="s2">&quot;basename&quot;</span><span class="p">],</span>
                                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">pred_var</span><span class="p">],</span>
                            <span class="p">)</span>
                            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;basename&quot;</span><span class="p">],</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
                            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">pred_var</span><span class="p">][</span><span class="s2">&quot;basename&quot;</span><span class="p">],</span>
                                <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;basename&quot;</span><span class="p">],</span>
                            <span class="p">)</span>
                <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;is_loop_index&quot;</span><span class="p">]:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;basename&quot;</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;basename&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">G</span></div></div>

<div class="viewcode-block" id="GroundedFunctionNetwork"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.GroundedFunctionNetwork">[docs]</a><span class="k">class</span> <span class="nc">GroundedFunctionNetwork</span><span class="p">(</span><span class="n">ComputationalGraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a GrFN model as a DiGraph with a set of input nodes and</span>
<span class="sd">    currently a single output. The DiGraph is composed of variable nodes and</span>
<span class="sd">    function nodes. Function nodes store an actual Python function with the</span>
<span class="sd">    expected set of ordered input arguments that correspond to the variable</span>
<span class="sd">    inputs of that node. Variable nodes store a value. This value can be any</span>
<span class="sd">    data type found in Python. When no value exists for a variable the value</span>
<span class="sd">    key will be set to None. Importantly only function nodes can be children or</span>
<span class="sd">    parents of variable nodes, and the reverse is also true. Both variable and</span>
<span class="sd">    function nodes can be inputs, but the output will always be a variable</span>
<span class="sd">    node.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">scope_tree</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_tree</span> <span class="o">=</span> <span class="n">scope_tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">n</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_call_graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_function_sets</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traverse_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">))</span>

<div class="viewcode-block" id="GroundedFunctionNetwork.traverse_nodes"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.GroundedFunctionNetwork.traverse_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">traverse_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_set</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;BFS traversal of nodes that returns name traversal as large string.</span>

<span class="sd">        Args:</span>
<span class="sd">            node_set: Set of input nodes to begin traversal.</span>
<span class="sd">            depth: Current traversal depth for child node viewing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            type: String containing tabbed traversal view.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tab</span> <span class="o">=</span> <span class="s2">&quot;  &quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node_set</span><span class="p">:</span>
            <span class="nb">repr</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">n</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span>
                <span class="k">else</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{n}</span><span class="s2">{inspect.signature(self.nodes[n][&#39;lambda_fn&#39;])}&quot;</span>
            <span class="p">)</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{tab * depth}</span><span class="si">{repr}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.from_json_and_lambdas"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.GroundedFunctionNetwork.from_json_and_lambdas">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json_and_lambdas</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">lambdas</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds a GrFN from a JSON object.</span>

<span class="sd">        Args:</span>
<span class="sd">            cls: The class variable for object creation.</span>
<span class="sd">            file: Filename of a GrFN JSON file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            type: A GroundedFunctionNetwork object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lambdas</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.from_dict"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.GroundedFunctionNetwork.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">lambdas</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds a GrFN object from a set of extracted function data objects</span>
<span class="sd">        and an associated file of lambda functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            cls: The class variable for object creation.</span>
<span class="sd">            data: A set of function data object that specify the wiring of a</span>
<span class="sd">                  GrFN object.</span>
<span class="sd">            lambdas: [Module] A python module containing actual python</span>
<span class="sd">                     functions to be computed during GrFN execution.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A GroundedFunctionNetwork object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]}</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">scope_tree</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">add_variable_node</span><span class="p">(</span>
            <span class="n">basename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">is_loop_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;</span><span class="si">{parent}</span><span class="s2">::</span><span class="si">{basename}</span><span class="s2">_</span><span class="si">{index}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;maroon&quot;</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{basename}</span><span class="s2">_</span><span class="si">{index}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">basename</span><span class="o">=</span><span class="n">basename</span><span class="p">,</span>
                <span class="n">is_loop_index</span><span class="o">=</span><span class="n">is_loop_index</span><span class="p">,</span>
                <span class="n">padding</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">find_correct_scope</span><span class="p">(</span><span class="n">cur_scope</span><span class="p">,</span> <span class="n">var_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cur_scope</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cur_scope</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">new_scope</span> <span class="o">=</span> <span class="n">cur_scope</span><span class="o">.</span><span class="n">parent</span>

            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">new_scope</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">new_scope</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">find_correct_scope</span><span class="p">(</span><span class="n">new_scope</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">process_container</span><span class="p">(</span>
            <span class="n">scope</span><span class="p">,</span> <span class="n">loop_index_variable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">stmt</span><span class="p">:</span>
                    <span class="n">stmt_type</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">stmt_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;assign&quot;</span><span class="p">,</span> <span class="s2">&quot;condition&quot;</span><span class="p">,</span> <span class="s2">&quot;decision&quot;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">stmt_type</span> <span class="o">==</span> <span class="s2">&quot;assign&quot;</span><span class="p">:</span>
                            <span class="k">if</span> <span class="s2">&quot;body&quot;</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">[</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]:</span>
                                <span class="n">stmt_type</span> <span class="o">=</span> <span class="s2">&quot;literal&quot;</span>

                        <span class="n">output</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span>
                        <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
                        <span class="n">add_variable_node</span><span class="p">(</span>
                            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span> <span class="n">scope</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                            <span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{scope.name}</span><span class="s2">::</span><span class="si">{output[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{output[&#39;index&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                        <span class="n">ordered_inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                        <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="p">[]):</span>
                            <span class="n">parent</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">name</span>
                            <span class="n">index</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
                            <span class="n">base_name</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                                <span class="ow">and</span> <span class="n">base_name</span> <span class="o">!=</span> <span class="n">loop_index_variable</span>
                            <span class="p">):</span>
                                <span class="n">parent</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">find_correct_scope</span><span class="p">(</span>
                                    <span class="n">scope</span><span class="p">,</span> <span class="n">base_name</span>
                                <span class="p">)</span>

                            <span class="n">add_variable_node</span><span class="p">(</span>
                                <span class="n">base_name</span><span class="p">,</span>
                                <span class="n">parent</span><span class="p">,</span>
                                <span class="n">index</span><span class="p">,</span>
                                <span class="n">base_name</span> <span class="o">==</span> <span class="n">loop_index_variable</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">node_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{parent}</span><span class="s2">::</span><span class="si">{base_name}</span><span class="s2">_</span><span class="si">{index}</span><span class="s2">&quot;</span>
                            <span class="n">ordered_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
                            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>

                        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                            <span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;function&quot;</span><span class="p">,</span>
                            <span class="n">lambda_fn</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">lambdas</span><span class="p">,</span> <span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]),</span>
                            <span class="n">func_inputs</span><span class="o">=</span><span class="n">ordered_inputs</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="s2">&quot;rectangle&quot;</span><span class="p">,</span>
                            <span class="n">parent</span><span class="o">=</span><span class="n">scope</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="n">stmt_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                            <span class="n">padding</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="k">elif</span> <span class="n">stmt_type</span> <span class="o">==</span> <span class="s2">&quot;loop_plate&quot;</span><span class="p">:</span>
                        <span class="n">index_variable</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]][</span>
                            <span class="s2">&quot;index_variable&quot;</span>
                        <span class="p">]</span>
                        <span class="n">scope_tree</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
                        <span class="n">scope_tree</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">scope</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
                        <span class="n">new_scope</span> <span class="o">=</span> <span class="n">ScopeNode</span><span class="p">(</span>
                            <span class="n">functions</span><span class="p">[</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]],</span> <span class="n">parent</span><span class="o">=</span><span class="n">scope</span>
                        <span class="p">)</span>
                        <span class="n">process_container</span><span class="p">(</span>
                            <span class="n">new_scope</span><span class="p">,</span> <span class="n">loop_index_variable</span><span class="o">=</span><span class="n">index_variable</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">elif</span> <span class="s2">&quot;function&quot;</span> <span class="ow">in</span> <span class="n">stmt</span> <span class="ow">and</span> <span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;print&quot;</span><span class="p">:</span>
                    <span class="n">scope_tree</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
                    <span class="n">scope_tree</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">scope</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">])</span>
                    <span class="n">new_scope</span> <span class="o">=</span> <span class="n">ScopeNode</span><span class="p">(</span>
                        <span class="n">functions</span><span class="p">[</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]],</span> <span class="n">parent</span><span class="o">=</span><span class="n">scope</span>
                    <span class="p">)</span>
                    <span class="n">process_container</span><span class="p">(</span><span class="n">new_scope</span><span class="p">)</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>
        <span class="n">scope_tree</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
        <span class="n">cur_scope</span> <span class="o">=</span> <span class="n">ScopeNode</span><span class="p">(</span><span class="n">functions</span><span class="p">[</span><span class="n">root</span><span class="p">])</span>
        <span class="n">process_container</span><span class="p">(</span><span class="n">cur_scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">scope_tree</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.from_python_file"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.GroundedFunctionNetwork.from_python_file.html#delphi.GrFN.networks.GroundedFunctionNetwork.from_python_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_python_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">python_file</span><span class="p">,</span> <span class="n">lambdas_path</span><span class="p">,</span> <span class="n">json_filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">stem</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds GrFN object from Python file.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">python_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pySrc</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_python_src</span><span class="p">(</span><span class="n">pySrc</span><span class="p">,</span> <span class="n">lambdas_path</span><span class="p">,</span> <span class="n">json_filename</span><span class="p">,</span> <span class="n">stem</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.from_python_src"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.GroundedFunctionNetwork.from_python_src.html#delphi.GrFN.networks.GroundedFunctionNetwork.from_python_src">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_python_src</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">pySrc</span><span class="p">,</span>
        <span class="n">lambdas_path</span><span class="p">,</span>
        <span class="n">json_filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">stem</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">save_file</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds GrFN object from Python source code.&quot;&quot;&quot;</span>
        <span class="n">asts</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">pySrc</span><span class="p">)]</span>
        <span class="n">pgm_dict</span> <span class="o">=</span> <span class="n">genPGM</span><span class="o">.</span><span class="n">create_pgm_dict</span><span class="p">(</span>
            <span class="n">lambdas_path</span><span class="p">,</span>
            <span class="n">asts</span><span class="p">,</span>
            <span class="n">json_filename</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">&quot;FileName&quot;</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{stem}</span><span class="s2">.py&quot;</span><span class="p">},</span>  <span class="c1"># HACK</span>
        <span class="p">)</span>
        <span class="n">lambdas</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="fm">__import__</span><span class="p">(</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;_lambdas&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">pgm_dict</span><span class="p">,</span> <span class="n">lambdas</span><span class="p">)</span></div>



<div class="viewcode-block" id="GroundedFunctionNetwork.from_fortran_file"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.GroundedFunctionNetwork.from_fortran_file.html#delphi.GrFN.networks.GroundedFunctionNetwork.from_fortran_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_fortran_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fortran_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">tmpdir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds GrFN object from a Fortran program.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tmpdir</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span> <span class="ow">and</span> <span class="s2">&quot;/&quot;</span> <span class="ow">in</span> <span class="n">fortran_file</span><span class="p">:</span>
            <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">fortran_file</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span>

        <span class="p">(</span>
                <span class="n">pySrc</span><span class="p">,</span>
                <span class="n">lambdas_path</span><span class="p">,</span>
                <span class="n">json_filename</span><span class="p">,</span>
                <span class="n">stem</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">f2grfn</span><span class="o">.</span><span class="n">fortran_to_grfn</span><span class="p">(</span><span class="n">fortran_file</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">))</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_python_src</span><span class="p">(</span><span class="n">pySrc</span><span class="p">,</span> <span class="n">lambdas_path</span><span class="p">,</span> <span class="n">json_filename</span><span class="p">,</span> <span class="n">stem</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.from_fortran_src"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.GroundedFunctionNetwork.from_fortran_src.html#delphi.GrFN.networks.GroundedFunctionNetwork.from_fortran_src">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_fortran_src</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fortran_src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a GroundedFunctionNetwork instance from a string with raw</span>
<span class="sd">        Fortran code.</span>

<span class="sd">        Args:</span>
<span class="sd">            fortran_src: A string with Fortran source code.</span>
<span class="sd">            dir: (Optional) - the directory in which the temporary Fortran file</span>
<span class="sd">                will be created (make sure you have write permission!) Defaults to</span>
<span class="sd">                the current directory.</span>
<span class="sd">        Returns:</span>
<span class="sd">            A GroundedFunctionNetwork instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w+t&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">fortran_src</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_fortran_file</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.clear"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.GroundedFunctionNetwork.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear variable nodes for next computation.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;func_visited&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.sobol_analysis"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.GroundedFunctionNetwork.sobol_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">sobol_analysis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">prob_def</span><span class="p">,</span> <span class="n">use_torch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">var_types</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">def</span> <span class="nf">create_input_tensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
            <span class="n">type_info</span> <span class="o">=</span> <span class="n">var_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">type_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">)</span> <span class="o">=</span> <span class="n">type_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">samples</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_input</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
            <span class="n">type_info</span> <span class="o">=</span> <span class="n">var_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">type_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">)</span> <span class="o">=</span> <span class="n">type_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">val1</span> <span class="k">if</span> <span class="n">sample</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="n">val2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sample</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">saltelli</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
            <span class="n">prob_def</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">calc_second_order</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">n</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_def</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">samples</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">n</span><span class="p">:</span> <span class="n">create_input_tensor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_def</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">samples</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">torch_size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">var_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_def</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">sample</span><span class="p">)}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">get_input</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_def</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">sample</span><span class="p">)}</span>

                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">sobol</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">prob_def</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.S2_surface"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.GroundedFunctionNetwork.S2_surface.html#delphi.GrFN.networks.GroundedFunctionNetwork.S2_surface">[docs]</a>    <span class="k">def</span> <span class="nf">S2_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">presets</span><span class="p">,</span> <span class="n">use_torch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the sensitivity surface of a GrFN for the two variables with</span>
<span class="sd">        the highest S2 index.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_samples: Number of samples for sensitivity analysis.</span>
<span class="sd">            sizes: Tuple of (number of x inputs, number of y inputs).</span>
<span class="sd">            bounds: Set of bounds for GrFN inputs.</span>
<span class="sd">            presets: Set of standard values for GrFN inputs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple:</span>
<span class="sd">                Tuple: The names of the two variables that were selected</span>
<span class="sd">                Tuple: The X, Y vectors of eval values</span>
<span class="sd">                Z: The numpy matrix of output evaluations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">Si</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sobol_analysis</span><span class="p">(</span>
            <span class="n">num_samples</span><span class="p">,</span>
            <span class="p">{</span>
                <span class="s2">&quot;num_vars&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span>
                <span class="s2">&quot;names&quot;</span><span class="p">:</span> <span class="n">args</span><span class="p">,</span>
                <span class="s2">&quot;bounds&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">bounds</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="p">)</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="n">Si</span><span class="p">[</span><span class="s2">&quot;S2&quot;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">s2_max</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_max_s2_sensitivity</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>

        <span class="n">x_var</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="n">y_var</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
        <span class="n">search_space</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x_var</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="n">x_var</span><span class="p">]),</span> <span class="p">(</span><span class="n">y_var</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="n">y_var</span><span class="p">])]</span>
        <span class="n">preset_vals</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">arg</span><span class="p">:</span> <span class="n">presets</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v2</span>
        <span class="p">}</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">search_space</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">search_space</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
            <span class="n">Xm</span><span class="p">,</span> <span class="n">Ym</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Xm</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">presets</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">search_space</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Xm</span><span class="p">,</span> <span class="n">search_space</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Ym</span><span class="p">})</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xm</span><span class="p">,</span> <span class="n">Ym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">))):</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">presets</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">inputs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">search_space</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="n">x</span><span class="p">,</span> <span class="n">search_space</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="n">y</span><span class="p">})</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">x_var</span><span class="p">,</span> <span class="n">y_var</span></div>


<div class="viewcode-block" id="GroundedFunctionNetwork.to_FIB"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.GroundedFunctionNetwork.to_FIB.html#delphi.GrFN.networks.GroundedFunctionNetwork.to_FIB">[docs]</a>    <span class="k">def</span> <span class="nf">to_FIB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a ForwardInfluenceBlanket object representing the</span>
<span class="sd">        intersection of this model with the other input model.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The GroundedFunctionNetwork object to compare this model to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A ForwardInfluenceBlanket object to use for model comparison.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GroundedFunctionNetwork</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Expected GroundedFunctionNetwork, but got {type(other)}&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">shortname</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">var</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">var</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">shortname_vars</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">shortname</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">shortname</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>

        <span class="n">this_var_nodes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">shortname</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">]</span>
        <span class="n">other_var_nodes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">shortname</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">]</span>

        <span class="n">shared_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">this_var_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">other_var_nodes</span><span class="p">))</span>
        <span class="n">full_shared_vars</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">full_var</span>
            <span class="k">for</span> <span class="n">shared_var</span> <span class="ow">in</span> <span class="n">shared_vars</span>
            <span class="k">for</span> <span class="n">full_var</span> <span class="ow">in</span> <span class="n">shortname_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared_var</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ForwardInfluenceBlanket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_shared_vars</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.to_agraph"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.GroundedFunctionNetwork.to_agraph.html#delphi.GrFN.networks.GroundedFunctionNetwork.to_agraph">[docs]</a>    <span class="k">def</span> <span class="nf">to_agraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Export to a PyGraphviz AGraph object. &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">to_agraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">graph_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;dpi&quot;</span><span class="p">:</span> <span class="mi">227</span><span class="p">,</span> <span class="s2">&quot;fontsize&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;fontname&quot;</span><span class="p">:</span> <span class="s2">&quot;Menlo&quot;</span><span class="p">,</span> <span class="s2">&quot;rankdir&quot;</span><span class="p">:</span> <span class="s2">&quot;TB&quot;</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fontname&quot;</span><span class="p">:</span> <span class="s2">&quot;Menlo&quot;</span><span class="p">})</span>

        <span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">cluster_name</span><span class="p">,</span> <span class="n">root_graph</span><span class="p">):</span>
            <span class="n">subgraph_nodes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;parent&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster_name</span>
            <span class="p">]</span>
            <span class="n">root_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">subgraph_nodes</span><span class="p">)</span>
            <span class="n">subgraph</span> <span class="o">=</span> <span class="n">root_graph</span><span class="o">.</span><span class="n">add_subgraph</span><span class="p">(</span>
                <span class="n">subgraph_nodes</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;cluster_</span><span class="si">{cluster_name}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">cluster_name</span><span class="p">,</span>
                <span class="n">style</span><span class="o">=</span><span class="s2">&quot;bold, rounded&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_tree</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">cluster_name</span><span class="p">):</span>
                <span class="n">build_tree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">subgraph</span><span class="p">)</span>

        <span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_tree</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">build_tree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.to_CAG_agraph"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.GroundedFunctionNetwork.to_CAG_agraph">[docs]</a>    <span class="k">def</span> <span class="nf">to_CAG_agraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a variable-only view of the GrFN in the form of an AGraph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            type: A CAG constructed via variable influence in the GrFN object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CAG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_CAG</span><span class="p">()</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">to_agraph</span><span class="p">(</span><span class="n">CAG</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">graph_attr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;dpi&quot;</span><span class="p">:</span> <span class="mi">227</span><span class="p">,</span> <span class="s2">&quot;fontsize&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;fontname&quot;</span><span class="p">:</span> <span class="s2">&quot;Menlo&quot;</span><span class="p">})</span>
        <span class="n">A</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;rectangle&quot;</span><span class="p">,</span>
                <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;#650021&quot;</span><span class="p">,</span>
                <span class="s2">&quot;style&quot;</span><span class="p">:</span> <span class="s2">&quot;rounded&quot;</span><span class="p">,</span>
                <span class="s2">&quot;fontname&quot;</span><span class="p">:</span> <span class="s2">&quot;Gill Sans&quot;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">edge_attr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;#650021&quot;</span><span class="p">,</span> <span class="s2">&quot;arrowsize&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">A</span></div>

<div class="viewcode-block" id="GroundedFunctionNetwork.to_call_agraph"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.GroundedFunctionNetwork.to_call_agraph.html#delphi.GrFN.networks.GroundedFunctionNetwork.to_call_agraph">[docs]</a>    <span class="k">def</span> <span class="nf">to_call_agraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Build a PyGraphviz AGraph object corresponding to a call graph of</span>
<span class="sd">        functions. &quot;&quot;&quot;</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">to_agraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">call_graph</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">graph_attr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;dpi&quot;</span><span class="p">:</span> <span class="mi">227</span><span class="p">,</span> <span class="s2">&quot;fontsize&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;fontname&quot;</span><span class="p">:</span> <span class="s2">&quot;Menlo&quot;</span><span class="p">})</span>
        <span class="n">A</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;rectangle&quot;</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;#650021&quot;</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">:</span> <span class="s2">&quot;rounded&quot;</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">edge_attr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;#650021&quot;</span><span class="p">,</span> <span class="s2">&quot;arrowsize&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">A</span></div></div>


<div class="viewcode-block" id="ForwardInfluenceBlanket"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.ForwardInfluenceBlanket">[docs]</a><span class="k">class</span> <span class="nc">ForwardInfluenceBlanket</span><span class="p">(</span><span class="n">ComputationalGraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class takes a network and a list of a shared nodes between the input</span>
<span class="sd">    network and a secondary network. From this list a shared nodes and blanket</span>
<span class="sd">    network is created including all of the nodes between any input/output pair</span>
<span class="sd">    in the shared nodes, as well as all nodes required to blanket the network</span>
<span class="sd">    for forward influence. This class itself becomes the blanket and inherits</span>
<span class="sd">    from the ComputationalGraph class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">GroundedFunctionNetwork</span><span class="p">,</span> <span class="n">shared_nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_node</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">output_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">shared_nodes</span><span class="p">)</span>

        <span class="c1"># Get all paths from shared inputs to shared outputs</span>
        <span class="n">path_inputs</span> <span class="o">=</span> <span class="n">shared_nodes</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_node</span><span class="p">}</span>
        <span class="n">io_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">inp</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">output_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">path_inputs</span><span class="p">]</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">p</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">in</span> <span class="n">io_pairs</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_simple_paths</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Get all edges needed to blanket the included nodes</span>
        <span class="n">main_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">path</span><span class="p">}</span>
        <span class="n">main_edges</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cover_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">add_nodes</span><span class="p">,</span> <span class="n">add_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">place_var_node</span><span class="p">(</span><span class="n">var_node</span><span class="p">):</span>
            <span class="n">prev_funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">var_node</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">prev_funcs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prev_funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span>
            <span class="p">):</span>
                <span class="n">prev_func</span> <span class="o">=</span> <span class="n">prev_funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">add_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">var_node</span><span class="p">,</span> <span class="n">prev_func</span><span class="p">])</span>
                <span class="n">add_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">prev_func</span><span class="p">,</span> <span class="n">var_node</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cover_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var_node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">main_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">var_node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">var_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">main_nodes</span><span class="p">:</span>
                        <span class="n">add_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">var_node</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                        <span class="k">if</span> <span class="s2">&quot;::IF_&quot;</span> <span class="ow">in</span> <span class="n">var_node</span><span class="p">:</span>
                            <span class="n">if_func</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">var_node</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">add_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">if_func</span><span class="p">,</span> <span class="n">var_node</span><span class="p">])</span>
                            <span class="n">add_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">if_func</span><span class="p">,</span> <span class="n">var_node</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">new_var_node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">if_func</span><span class="p">):</span>
                                <span class="n">add_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_var_node</span><span class="p">,</span> <span class="n">if_func</span><span class="p">))</span>
                                <span class="n">place_var_node</span><span class="p">(</span><span class="n">new_var_node</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">place_var_node</span><span class="p">(</span><span class="n">var_node</span><span class="p">)</span>

        <span class="n">main_nodes</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">add_nodes</span><span class="p">)</span>
        <span class="n">main_edges</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">add_edges</span><span class="p">)</span>
        <span class="n">main_nodes</span> <span class="o">=</span> <span class="n">main_nodes</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_node</span><span class="p">}</span>

        <span class="n">orig_nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">orig_nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dodgerblue3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;fontcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dodgerblue3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;penwidth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;fontname&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FONT</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">orig_nodes</span>
                            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cover_nodes</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cover_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;fontname&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FONT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forestgreen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;fontcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forestgreen</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">orig_nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">main_nodes</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">main_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;fontname&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FONT</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_node</span><span class="p">,</span> <span class="o">**</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">output_node</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">output_node</span><span class="p">][</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dodgerblue3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">output_node</span><span class="p">][</span><span class="s2">&quot;fontcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dodgerblue3</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">main_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_call_graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_function_sets</span><span class="p">()</span>

<div class="viewcode-block" id="ForwardInfluenceBlanket.run"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.ForwardInfluenceBlanket.run.html#delphi.GrFN.networks.ForwardInfluenceBlanket.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]],</span>
        <span class="n">covers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]],</span>
        <span class="n">torch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Executes the FIB over a particular set of inputs and returns the</span>
<span class="sd">        result.</span>
<span class="sd">        Args:</span>
<span class="sd">            inputs: Input set where keys are the names of input nodes in the</span>
<span class="sd">              GrFN and each key points to a set of input values (or just one).</span>
<span class="sd">        Returns:</span>
<span class="sd">            A set of outputs from executing the GrFN, one for every set of</span>
<span class="sd">            inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Abort run if covers does not match our expected cover set</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">covers</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cover_nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect number of cover values.&quot;</span><span class="p">)</span>

        <span class="c1"># Set the cover node values</span>
        <span class="k">for</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">covers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_name</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">torch_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="ForwardInfluenceBlanket.sobol_analysis"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.ForwardInfluenceBlanket.sobol_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">sobol_analysis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">prob_def</span><span class="p">,</span> <span class="n">covers</span><span class="p">,</span> <span class="n">use_torch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">var_types</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">def</span> <span class="nf">create_input_tensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
            <span class="n">type_info</span> <span class="o">=</span> <span class="n">var_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">type_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">)</span> <span class="o">=</span> <span class="n">type_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">samples</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">saltelli</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
            <span class="n">prob_def</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">calc_second_order</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">n</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_def</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">samples</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">n</span><span class="p">:</span> <span class="n">create_input_tensor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_def</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">samples</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">covers</span><span class="p">,</span> <span class="n">torch_size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_def</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">sample</span><span class="p">)}</span>
                <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">covers</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sobol</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">prob_def</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span></div>

<div class="viewcode-block" id="ForwardInfluenceBlanket.S2_surface"><a class="viewcode-back" href="../../../generated/delphi.GrFN.networks.ForwardInfluenceBlanket.S2_surface.html#delphi.GrFN.networks.ForwardInfluenceBlanket.S2_surface">[docs]</a>    <span class="k">def</span> <span class="nf">S2_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">presets</span><span class="p">,</span> <span class="n">covers</span><span class="p">,</span> <span class="n">use_torch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the sensitivity surface of a GrFN for the two variables with</span>
<span class="sd">        the highest S2 index.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_samples: Number of samples for sensitivity analysis.</span>
<span class="sd">            sizes: Tuple of (number of x inputs, number of y inputs).</span>
<span class="sd">            bounds: Set of bounds for GrFN inputs.</span>
<span class="sd">            presets: Set of standard values for GrFN inputs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple:</span>
<span class="sd">                Tuple: The names of the two variables that were selected</span>
<span class="sd">                Tuple: The X, Y vectors of eval values</span>
<span class="sd">                Z: The numpy matrix of output evaluations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">Si</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sobol_analysis</span><span class="p">(</span>
            <span class="n">num_samples</span><span class="p">,</span>
            <span class="p">{</span>
                <span class="s2">&quot;num_vars&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span>
                <span class="s2">&quot;names&quot;</span><span class="p">:</span> <span class="n">args</span><span class="p">,</span>
                <span class="s2">&quot;bounds&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">bounds</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="n">covers</span>
        <span class="p">)</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="n">Si</span><span class="p">[</span><span class="s2">&quot;S2&quot;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">s2_max</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_max_s2_sensitivity</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>

        <span class="n">x_var</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="n">y_var</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
        <span class="n">search_space</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x_var</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="n">x_var</span><span class="p">]),</span> <span class="p">(</span><span class="n">y_var</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="n">y_var</span><span class="p">])]</span>
        <span class="n">preset_vals</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">arg</span><span class="p">:</span> <span class="n">presets</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v2</span>
        <span class="p">}</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">search_space</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">search_space</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
            <span class="n">Xm</span><span class="p">,</span> <span class="n">Ym</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">Xm</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">presets</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">search_space</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Xm</span><span class="p">,</span> <span class="n">search_space</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Ym</span><span class="p">})</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">covers</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xm</span><span class="p">,</span> <span class="n">Ym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">))):</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">presets</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">inputs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">search_space</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="n">x</span><span class="p">,</span> <span class="n">search_space</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="n">y</span><span class="p">})</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">covers</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">x_var</span><span class="p">,</span> <span class="n">y_var</span></div>

<div class="viewcode-block" id="ForwardInfluenceBlanket.to_agraph"><a class="viewcode-back" href="../../../delphi.GrFN.html#delphi.GrFN.networks.ForwardInfluenceBlanket.to_agraph">[docs]</a>    <span class="k">def</span> <span class="nf">to_agraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">to_agraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">graph_attr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;dpi&quot;</span><span class="p">:</span> <span class="mi">227</span><span class="p">,</span> <span class="s2">&quot;fontsize&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span>
        <span class="n">A</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;rectangle&quot;</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">:</span> <span class="s2">&quot;rounded&quot;</span><span class="p">})</span>
        <span class="n">A</span><span class="o">.</span><span class="n">edge_attr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;arrowsize&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">A</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Adarsh

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>