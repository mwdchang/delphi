

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>delphi.translators.for2py.translate &mdash; delphi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script type="text/javascript" src="../../../../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> delphi
          

          
            
            <img src="../../../../_static/delphi_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../AnalysisGraph_API.html">AnalysisGraph API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_spec.html">Grounded Function Network (GrFN) JSON Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_spec.html#change-log">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cpp_api/library_root.html">C++ API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">delphi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../for2py.html">delphi.translators.for2py</a> &raquo;</li>
        
      <li>delphi.translators.for2py.translate</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for delphi.translators.for2py.translate</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This script converts the XML version of AST of the Fortran</span>
<span class="sd">file into a JSON representation of the AST along with other</span>
<span class="sd">non-source code information. The output is a pickled file</span>
<span class="sd">which contains this information in a parsable data structure.</span>

<span class="sd">Example:</span>
<span class="sd">    This script is executed by the autoTranslate script as one</span>
<span class="sd">    of the steps in converted a Fortran source file to Python</span>
<span class="sd">    file. For standalone execution:::</span>

<span class="sd">        python translate.py -f &lt;ast_file&gt; -g &lt;pickle_file&gt; -i &lt;f_src_file&gt;</span>

<span class="sd">    where f_src_file is the Fortran source file for ast_file.</span>

<span class="sd">ast_file: The XML representation of the AST of the Fortran file. This is</span>
<span class="sd">produced by the OpenFortranParser.</span>

<span class="sd">pickle_file: The file which will contain the pickled version of JSON AST and</span>
<span class="sd">supporting information. &quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.get_comments</span> <span class="k">import</span> <span class="n">get_comments</span>


<div class="viewcode-block" id="ParseState"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.ParseState">[docs]</a><span class="k">class</span> <span class="nc">ParseState</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class defines the state of the XML tree parsing</span>
<span class="sd">    at any given root. For any level of the tree, it stores</span>
<span class="sd">    the subroutine under which it resides along with the</span>
<span class="sd">    subroutines arguments.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subroutine</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subroutine</span> <span class="o">=</span> <span class="n">subroutine</span> <span class="k">if</span> <span class="n">subroutine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s2">&quot;args&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutine</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="ParseState.copy"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.ParseState.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subroutine</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ParseState</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subroutine</span> <span class="k">if</span> <span class="n">subroutine</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">subroutine</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="XML_to_JSON_translator"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator">[docs]</a><span class="k">class</span> <span class="nc">XML_to_JSON_translator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">libRtns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">,</span> <span class="s2">&quot;open&quot;</span><span class="p">,</span> <span class="s2">&quot;close&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;print&quot;</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">libFns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;mod&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exp&quot;</span><span class="p">,</span>
            <span class="s2">&quot;index&quot;</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">,</span>
            <span class="s2">&quot;max&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cexp&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cmplx&quot;</span><span class="p">,</span>
            <span class="s2">&quot;atan&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cos&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sin&quot;</span><span class="p">,</span>
            <span class="s2">&quot;acos&quot;</span><span class="p">,</span>
            <span class="s2">&quot;asin&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tan&quot;</span><span class="p">,</span>
            <span class="s2">&quot;atan&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sqrt&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handled_tags</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;access-spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;argument&quot;</span><span class="p">,</span>
            <span class="s2">&quot;assignment&quot;</span><span class="p">,</span>
            <span class="s2">&quot;call&quot;</span><span class="p">,</span>
            <span class="s2">&quot;close&quot;</span><span class="p">,</span>
            <span class="s2">&quot;component-decl&quot;</span><span class="p">,</span>
            <span class="s2">&quot;declaration&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dimension&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dimensions&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exit&quot;</span><span class="p">,</span>
            <span class="s2">&quot;explicit-shape-spec-list__begin&quot;</span><span class="p">,</span>
            <span class="s2">&quot;format&quot;</span><span class="p">,</span>
            <span class="s2">&quot;format-item&quot;</span><span class="p">,</span>
            <span class="s2">&quot;function&quot;</span><span class="p">,</span>
            <span class="s2">&quot;if&quot;</span><span class="p">,</span>
            <span class="s2">&quot;index-variable&quot;</span><span class="p">,</span>
            <span class="s2">&quot;io-control-spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;keyword-argument&quot;</span><span class="p">,</span>
            <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;loop&quot;</span><span class="p">,</span>
            <span class="s2">&quot;module&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;open&quot;</span><span class="p">,</span>
            <span class="s2">&quot;operation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;program&quot;</span><span class="p">,</span>
            <span class="s2">&quot;range&quot;</span><span class="p">,</span>
            <span class="s2">&quot;read&quot;</span><span class="p">,</span>
            <span class="s2">&quot;return&quot;</span><span class="p">,</span>
            <span class="s2">&quot;stop&quot;</span><span class="p">,</span>
            <span class="s2">&quot;subroutine&quot;</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">,</span>
            <span class="s2">&quot;use&quot;</span><span class="p">,</span>
            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">,</span>
            <span class="s2">&quot;write&quot;</span><span class="p">,</span>
            <span class="s2">&quot;save-stmt&quot;</span><span class="p">,</span>
            <span class="s2">&quot;saved-entity&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handled_tags</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">libRtns</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ast_tag_handlers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;argument&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_argument</span><span class="p">,</span>
            <span class="s2">&quot;assignment&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_assignment</span><span class="p">,</span>
            <span class="s2">&quot;call&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_call</span><span class="p">,</span>
            <span class="s2">&quot;close&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_direct_map</span><span class="p">,</span>
            <span class="s2">&quot;declaration&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_declaration</span><span class="p">,</span>
            <span class="s2">&quot;dimension&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_dimension</span><span class="p">,</span>
            <span class="s2">&quot;exit&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_terminal</span><span class="p">,</span>
            <span class="s2">&quot;format-item&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_format_item</span><span class="p">,</span>
            <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_format</span><span class="p">,</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_function</span><span class="p">,</span>
            <span class="s2">&quot;if&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_if</span><span class="p">,</span>
            <span class="s2">&quot;index-variable&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_index_variable</span><span class="p">,</span>
            <span class="s2">&quot;io-controls&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_io_control</span><span class="p">,</span>
            <span class="s2">&quot;keyword-argument&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_keyword_argument</span><span class="p">,</span>
            <span class="s2">&quot;literal&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_literal</span><span class="p">,</span>
            <span class="s2">&quot;loop&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_loop</span><span class="p">,</span>
            <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_subroutine_or_program_module</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_name</span><span class="p">,</span>
            <span class="s2">&quot;open&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_direct_map</span><span class="p">,</span>
            <span class="s2">&quot;operation&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_operation</span><span class="p">,</span>
            <span class="s2">&quot;program&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_subroutine_or_program_module</span><span class="p">,</span>
            <span class="s2">&quot;range&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_range</span><span class="p">,</span>
            <span class="s2">&quot;read&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_direct_map</span><span class="p">,</span>
            <span class="s2">&quot;return&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_terminal</span><span class="p">,</span>
            <span class="s2">&quot;stop&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_terminal</span><span class="p">,</span>
            <span class="s2">&quot;subroutine&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_subroutine_or_program_module</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_type</span><span class="p">,</span>
            <span class="s2">&quot;use&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_use</span><span class="p">,</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_variables</span><span class="p">,</span>
            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_variable</span><span class="p">,</span>
            <span class="s2">&quot;write&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_direct_map</span><span class="p">,</span>
            <span class="s2">&quot;derived-types&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_derived_types</span><span class="p">,</span>
            <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_length</span><span class="p">,</span>
            <span class="s2">&quot;save-stmt&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_save</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># unhandled xml tags in the current input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryPoint</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Dictionary to map all the variables defined in each function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Dictionary to map the arguments to their functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># String that holds the current function under context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Flag that specifies whether a SAVE statement has been encountered</span>
        <span class="c1"># in the subroutine/function or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Variable to hold the node of the SAVE statement to process at the</span>
        <span class="c1"># end of the subroutine/function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saved_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># This list holds the nodes of the file handles that needs to be</span>
        <span class="c1"># SAVEd in the python translated code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="XML_to_JSON_translator.process_subroutine_or_program_module"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_subroutine_or_program_module">[docs]</a>    <span class="k">def</span> <span class="nf">process_subroutine_or_program_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function should be the very first function to be called &quot;&quot;&quot;</span>
        <span class="n">subroutine</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryPoint</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                <span class="n">subState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">subroutine</span><span class="p">)</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">subState</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;members&quot;</span><span class="p">:</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">subState</span><span class="p">)</span>

        <span class="c1"># Check if this subroutine had a save statement and if so, process</span>
        <span class="c1"># the saved node to add it to the ast</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span><span class="p">:</span>
            <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saved_node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">:</span>
            <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;save&quot;</span><span class="p">,</span> <span class="s2">&quot;scope&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span> <span class="s2">&quot;var_list&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">}]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">asts</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">subroutine</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">subroutine</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_call"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_call">[docs]</a>    <span class="k">def</span> <span class="nf">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;call&gt; tag and its subelement &lt;name&gt;. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;call&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;call&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;call&quot;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                <span class="n">call</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">call</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">call</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">call</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_argument"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_argument">[docs]</a>    <span class="k">def</span> <span class="nf">process_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;argument&gt; tag. It simply create a new AST</span>
<span class="sd">        list and copy the values (tag and attributes) to it.  &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;argument&quot;</span><span class="p">,</span> <span class="s2">&quot;The root must be &lt;argument&gt;&quot;</span>
        <span class="n">var_name</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># Store each argument respective to the function it is defined in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;arg&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">var_name</span><span class="p">}]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_declaration"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_declaration">[docs]</a>    <span class="k">def</span> <span class="nf">process_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;declaration&gt; tag and its sub-elements by</span>
<span class="sd">        recursively calling the appropriate functions for the target tag. &quot;&quot;&quot;</span>

        <span class="n">declared_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">declared_variable</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;declaration&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;declaration&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span>\
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handled_tags</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>  <span class="c1"># Get the variable type</span>
                <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span><span class="p">:</span>
                    <span class="n">declared_type</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If the current node is for declaring a derived type,</span>
                    <span class="c1"># every step from type declaration to variable (including</span>
                    <span class="c1"># array) declaration will be done in the</span>
                    <span class="c1"># &quot;process_derived_types&quot; function and return the completed</span>
                    <span class="c1"># AST list object back.  Thus, simply insert the received</span>
                    <span class="c1"># AST list object into the declared_variable object. No</span>
                    <span class="c1"># other work is done in the current function.</span>
                    <span class="n">declared_variable</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span>
                <span class="n">num_of_dimensions</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])</span>
                <span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">num_of_dimensions</span><span class="p">,</span>
                    <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">),</span>
                <span class="p">}</span>
                <span class="c1"># Since we always want to access the last element of the list</span>
                <span class="c1"># that was added most recently (that is a currently handling</span>
                <span class="c1"># variable), add [-1] index to access it.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">declared_type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">declared_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">declared_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="c1"># Declare variables based on the counts to handle the case</span>
                <span class="c1"># where a multiple variables declared under a single type</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">declared_type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">combined</span> <span class="o">=</span> <span class="n">declared_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">combined</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                        <span class="n">declared_variable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span>
                            <span class="ow">and</span> <span class="n">declared_variable</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">args</span>
                        <span class="p">):</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">][</span>
                                <span class="n">state</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                                    <span class="n">declared_variable</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">declared_variable</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">declared_variable</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">][</span>
                                <span class="n">state</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                                    <span class="n">declared_variable</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">declared_variable</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;save-stmt&quot;</span><span class="p">:</span>
                <span class="n">declared_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="c1"># Create an exclusion list of all variables which are arguments</span>
        <span class="c1"># to the function/subroutine in context and to</span>
        <span class="c1"># function/subroutine names themselves</span>
        <span class="n">exclusion_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">):</span>
            <span class="n">exclusion_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]</span>
        <span class="n">exclusion_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">]))</span>

        <span class="c1"># Map each variable declaration to this parent</span>
        <span class="c1"># function/subroutine to keep a track of local variables</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">declared_variable</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">declared_variable</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">]</span> <span class="ow">and</span>
                        <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;is_derived_type&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
                     <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span>
                                          <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">declared_variable</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_type"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_type">[docs]</a>    <span class="k">def</span> <span class="nf">process_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;type&gt; declaration.</span>
<span class="sd">        There may be two different cases of &lt;type&gt;.</span>
<span class="sd">            (1) Simple variable type declaration</span>
<span class="sd">            (2) Derived type declaration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;type&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">declared_type</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">derived_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">text</span>
        <span class="p">):</span>  <span class="c1"># Check if the &lt;type&gt; has sub-elements, which is the case of (2)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
                    <span class="n">derived_type</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span>
                    <span class="n">is_derived_type</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="s2">&quot;is_derived_type&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                        <span class="n">is_derived_type</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span>
                            <span class="s2">&quot;is_derived_type&quot;</span>
                        <span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="n">keyword2</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
                    <span class="k">if</span> <span class="s2">&quot;keyword2&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                        <span class="n">keyword2</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;keyword2&quot;</span><span class="p">]</span>
                    <span class="n">declared_type</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="n">is_derived_type</span><span class="p">,</span>
                        <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="n">keyword2</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="n">declared_type</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">declared_type</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;derived-types&quot;</span><span class="p">:</span>
                    <span class="n">derived_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">derived_type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Else, this represents an empty element, which is the case of (1).</span>
            <span class="n">declared_type</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_derived_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;keyword2&quot;</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">declared_type</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_length"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_length">[docs]</a>    <span class="k">def</span> <span class="nf">process_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;length&gt; tag.  &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;length&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;length&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
                <span class="n">length</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">length</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_variables"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_variables">[docs]</a>    <span class="k">def</span> <span class="nf">process_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;variables&gt; element, which its duty is to</span>
<span class="sd">        call &lt;variable&gt; tag processor. &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variables&quot;</span>
            <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;variables&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> &quot;</span> \
                <span class="n">f</span><span class="s2">&quot;with </span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">variables</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_variable"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_variable">[docs]</a>    <span class="k">def</span> <span class="nf">process_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function will get called from the process_variables function, and</span>
<span class="sd">        it will construct the variable AST list, then return it back to the</span>
<span class="sd">        called function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;variable&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">is_array</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_array&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

            <span class="n">variable</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">var_name</span><span class="p">,</span> <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="n">is_array</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">is_array</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span>

            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">text</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;initial-value&quot;</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                        <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_derived_types"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_derived_types">[docs]</a>    <span class="k">def</span> <span class="nf">process_derived_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;derived-types&gt; tag nested in the &lt;type&gt; tag.</span>
<span class="sd">        Depends on the nested sub-elements of the tag, it will recursively call</span>
<span class="sd">        other tag processors.</span>

<span class="sd">        (1) Main type declaration</span>
<span class="sd">        (2) Single variable declaration (with initial values)</span>
<span class="sd">        (3) Array declaration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;derived-types&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;derived-type&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">derived_types</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;derived-types&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="n">declared_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">declared_variable</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handled_tags</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>  <span class="c1"># Get the variable type</span>
                <span class="n">declared_type</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span>
                <span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;dimension&quot;</span><span class="p">}],</span>
                <span class="p">}</span>
                <span class="n">dimensions</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">declared_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="c1"># declare variables based on the counts to handle the case</span>
                <span class="c1"># where a multiple vars declared under a single type</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])):</span>
                    <span class="n">combined</span> <span class="o">=</span> <span class="n">declared_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">combined</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                    <span class="n">derived_types</span><span class="p">[</span><span class="s2">&quot;derived-types&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">derived_types</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_loop"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_loop">[docs]</a>    <span class="k">def</span> <span class="nf">process_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;loop type=&quot;&quot;&gt; tag.  The type attribute</span>
<span class="sd">        indicates the current loop is either &quot;do&quot; or &quot;do-while&quot; loop. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;loop&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;loop&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;do&quot;</span><span class="p">:</span>
            <span class="n">do</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;do&quot;</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                    <span class="n">do</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                    <span class="n">do</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="kc">False</span>
                    <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;Unrecognized tag in the process_loop for &#39;do&#39; type.&quot;</span> \
                        <span class="n">f</span><span class="s2">&quot;</span><span class="si">{node.tag}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">do</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;do-while&quot;</span><span class="p">:</span>
            <span class="n">doWhile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;do-while&quot;</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                    <span class="n">doWhile</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                    <span class="n">doWhile</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">doWhile</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_index_variable"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_index_variable">[docs]</a>    <span class="k">def</span> <span class="nf">process_index_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;index-variable&gt; tag. This tag represents</span>
<span class="sd">        index ranges of loops or arrays. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;index-variable&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;index-variable&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;with </span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;lower-bound&quot;</span><span class="p">:</span>
                <span class="n">ind</span><span class="p">[</span><span class="s2">&quot;low&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bounds</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;upper-bound&quot;</span><span class="p">:</span>
                <span class="n">ind</span><span class="p">[</span><span class="s2">&quot;high&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bounds</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;step&quot;</span><span class="p">:</span>
                <span class="n">ind</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ind</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_if"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_if">[docs]</a>    <span class="k">def</span> <span class="nf">process_if</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;if&gt; tag. Else and else if are nested under</span>
<span class="sd">        this tag. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;if&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;if&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">ifs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">curIf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                    <span class="n">curIf</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;if&quot;</span><span class="p">}</span>
                    <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="n">ifs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curIf</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;else-if&quot;</span><span class="p">:</span>
                    <span class="n">newIf</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;if&quot;</span><span class="p">}</span>
                    <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;else&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newIf</span><span class="p">]</span>
                    <span class="n">curIf</span> <span class="o">=</span> <span class="n">newIf</span>
                    <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="s2">&quot;type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;else&quot;</span>
            <span class="p">):</span>
                <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;else&quot;</span><span class="p">:</span>
                <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;else&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ifs</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_operation"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_operation">[docs]</a>    <span class="k">def</span> <span class="nf">process_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;operation&gt; tag. The nested elements should</span>
<span class="sd">        either be &quot;operand&quot; or &quot;operator&quot;. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;operation&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;operation&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;op&quot;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;operand&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;left&quot;</span> <span class="ow">in</span> <span class="n">op</span><span class="p">:</span>
                    <span class="n">op</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">op</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;operator&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;operator&quot;</span> <span class="ow">in</span> <span class="n">op</span><span class="p">:</span>
                    <span class="n">newOp</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;op&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;operator&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;operator&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">op</span><span class="p">],</span>
                    <span class="p">}</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">newOp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">op</span><span class="p">[</span><span class="s2">&quot;operator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;operator&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_literal"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_literal">[docs]</a>    <span class="k">def</span> <span class="nf">process_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;literal&gt; tag &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;literal&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;pause-stmt&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;pause&quot;</span><span class="p">,</span> <span class="s2">&quot;msg&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]}]</span>
            <span class="k">elif</span> <span class="n">info</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;stop&quot;</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;stop&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">text</span><span class="p">}]</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">],</span>
            <span class="p">}</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="XML_to_JSON_translator.process_io_control"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_io_control">[docs]</a>    <span class="k">def</span> <span class="nf">process_io_control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function checks for an asterisk in the argument of a</span>
<span class="sd">        read/write statement and stores it if found.  An asterisk in the first</span>
<span class="sd">        argument specifies a input through or output to console.  An asterisk</span>
<span class="sd">        in the second argument specifies a read/write without a format</span>
<span class="sd">        (implicit read/writes).  &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;io-controls&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;io-controls&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">io_control</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasExpression&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="s2">&quot;hasExpression&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span>
                    <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasExpression&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span>
                <span class="p">),</span> <span class="s2">&quot;hasExpression is false. Something is wrong.&quot;</span>
                <span class="n">io_control</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasAsterisk&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span>
                <span class="p">),</span> <span class="s2">&quot;hasAsterisk is false. Something is wrong.&quot;</span>
                <span class="n">io_control</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;char&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span><span class="p">}</span>
                <span class="p">]</span>
        <span class="k">return</span> <span class="n">io_control</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_name">[docs]</a>    <span class="k">def</span> <span class="nf">process_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;name&gt; tag. The name tag will be added to the</span>
<span class="sd">        new AST for the pyTranslate.py with &quot;ref&quot; tag.  &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;name&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">libFns</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;call&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span>
            <span class="c1"># and state.subroutine[&quot;tag&quot;] != &quot;function&quot;</span>
        <span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;call&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># numPartRef represents the number of references in the name.</span>
            <span class="c1"># Default = 1</span>
            <span class="n">numPartRef</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
            <span class="c1"># For example, numPartRef of x is 1 while numPartRef of</span>
            <span class="c1"># x.y is 2, etc.</span>
            <span class="k">if</span> <span class="s2">&quot;numPartRef&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">numPartRef</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;numPartRef&quot;</span><span class="p">]</span>

            <span class="n">is_array</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;is_array&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">is_array</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_array&quot;</span><span class="p">]</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">numPartRef</span><span class="p">),</span>
                <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasSubscripts&quot;</span><span class="p">],</span>
                <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="n">is_array</span><span class="p">,</span>
                <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="c1"># Check whether the passed element is for derived type reference</span>
            <span class="k">if</span> <span class="s2">&quot;is_derived_type_ref&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">ref</span><span class="p">[</span><span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref</span><span class="p">[</span><span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>
            <span class="c1"># Handling derived type references</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPartRef</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                        <span class="n">nextRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                        <span class="n">ref</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;ref&quot;</span><span class="p">:</span> <span class="n">nextRef</span><span class="p">})</span>

            <span class="c1"># Handling arrays</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasSubscripts&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;subscripts&quot;</span><span class="p">:</span>
                        <span class="n">ref</span><span class="p">[</span><span class="s2">&quot;subscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_assignment"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_assignment">[docs]</a>    <span class="k">def</span> <span class="nf">process_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;assignment&gt; tag that nested elements of</span>
<span class="sd">        &lt;target&gt; and &lt;value&gt;. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;assignment&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;assignment&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">assign</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;assignment&quot;</span><span class="p">}</span>
        <span class="n">devTypeAssignment</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
                <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
                <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="p">]</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">state</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;ret&quot;</span>
            <span class="k">return</span> <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">assign</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_function"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_function">[docs]</a>    <span class="k">def</span> <span class="nf">process_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;function&gt; tag.  &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;function&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with&quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">subroutine</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="n">arg</span><span class="p">[</span><span class="s2">&quot;is_arg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                <span class="n">subState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">subroutine</span><span class="p">)</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">subState</span><span class="p">)</span>

        <span class="c1"># Check if this subroutine had a save statement and if so, process</span>
        <span class="c1"># the saved node to add it to the ast</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span><span class="p">:</span>
            <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saved_node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">:</span>
            <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;save&quot;</span><span class="p">,</span> <span class="s2">&quot;scope&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span> <span class="s2">&quot;var_list&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">}]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">asts</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">subroutine</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">subroutine</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_dimension"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">process_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;dimension&gt; tag. This is a tag that holds</span>
<span class="sd">        information about the array, such as the range and values. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dimension&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;dimension&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;dimension&quot;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;range&quot;</span><span class="p">:</span>
                <span class="n">dimension</span><span class="p">[</span><span class="s2">&quot;range&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
                <span class="n">dimension</span><span class="p">[</span><span class="s2">&quot;literal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">dimension</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_range"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_range">[docs]</a>    <span class="k">def</span> <span class="nf">process_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;range&gt; tag.  &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;range&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;range&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">ran</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;lower-bound&quot;</span><span class="p">:</span>
                <span class="n">ran</span><span class="p">[</span><span class="s2">&quot;low&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;upper-bound&quot;</span><span class="p">:</span>
                <span class="n">ran</span><span class="p">[</span><span class="s2">&quot;high&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ran</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_keyword_argument"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_keyword_argument">[docs]</a>    <span class="k">def</span> <span class="nf">process_keyword_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;keyword-argument&gt; tag. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;keyword-argument&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;keyword-argument&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;with </span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;argument-name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;arg_name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;argument-name&quot;</span><span class="p">]}]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_libRtn"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_libRtn">[docs]</a>    <span class="k">def</span> <span class="nf">process_libRtn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;call&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_direct_map"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_direct_map">[docs]</a>    <span class="k">def</span> <span class="nf">process_direct_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Handles tags that are mapped directly from xml to IR with no</span>
<span class="sd">        additional processing other than recursive translation of any child</span>
<span class="sd">        nodes.&quot;&quot;&quot;</span>

        <span class="n">val</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">val</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="c1"># If the node is a file OPEN node, save it so that it can later be</span>
        <span class="c1"># added to the SAVE node in the ast</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;open&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span> <span class="o">+=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_terminal"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_terminal">[docs]</a>    <span class="k">def</span> <span class="nf">process_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Handles tags that terminate the computation of a</span>
<span class="sd">        program unit, namely, &quot;return&quot;, &quot;stop&quot;, and &quot;exit&quot; &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">}]</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function handles &lt;format&gt; tag.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="XML_to_JSON_translator.process_format"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_format">[docs]</a>    <span class="k">def</span> <span class="nf">process_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;format&gt; tag. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;format&quot;</span>
        <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The root must be &lt;format&gt;. Current tag is </span><span class="si">{root.tag}</span><span class="s2"> with &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{root.attrib}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">format_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span>
                <span class="n">format_spec</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;lbl&quot;</span><span class="p">]</span>
            <span class="n">format_spec</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">format_spec</span><span class="p">]</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function handles &lt;format-item&gt; tag.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="XML_to_JSON_translator.process_format_item"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_format_item">[docs]</a>    <span class="k">def</span> <span class="nf">process_format_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;format-item&gt; tag. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;format-item&quot;</span><span class="p">,</span> <span class="s2">&quot;The root must be &lt;format-item&gt;&quot;</span>
        <span class="n">variable_spec</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;char&quot;</span><span class="p">,</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;descOrDigit&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable_spec</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_use"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_use">[docs]</a>    <span class="k">def</span> <span class="nf">process_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function adds the tag for use statements</span>
<span class="sd">            In case of &quot;USE .. ONLY ..&quot; statements, the symbols to be included</span>
<span class="sd">            are stored in the &quot;include&quot; field of the &quot;use&quot; block</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tag_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;use&quot;</span><span class="p">,</span> <span class="s2">&quot;arg&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;only&quot;</span><span class="p">:</span>
                <span class="n">tag_spec</span><span class="p">[</span><span class="s2">&quot;include&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                        <span class="n">tag_spec</span><span class="p">[</span><span class="s2">&quot;include&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">tag_spec</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="XML_to_JSON_translator.process_private_variable"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_private_variable">[docs]</a>    <span class="k">def</span> <span class="nf">process_private_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function adds the tag for private symbols. Any</span>
<span class="sd">        variable/function being initialized as private is added in this tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;private&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()}]</span>

        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_save"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_save">[docs]</a>    <span class="k">def</span> <span class="nf">process_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function parses the XML tag for the Fortran save statement and</span>
<span class="sd">        adds the tag that holds the function under which SAVE has been</span>
<span class="sd">        defined along with the variables that are saved by this statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If is_save is False, the SAVE statement has been encountered for</span>
        <span class="c1"># the first time in the particular subroutine/function in context.</span>
        <span class="c1"># Here, change the flag value and save the SAVE node.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_node</span> <span class="o">=</span> <span class="n">root</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This block will be entered when a SAVE statement is present</span>
            <span class="c1"># and its corresponding ast node has to be added at the end of</span>
            <span class="c1"># the subroutine/function body. Here the saved SAVE node</span>
            <span class="c1"># is processed as root.</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasSavedEntityList&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="n">var_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span>
                            <span class="n">var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">:</span>
                <span class="n">var_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span>
            <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;save&quot;</span><span class="p">,</span> <span class="s2">&quot;scope&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span> <span class="s2">&quot;var_list&quot;</span><span class="p">:</span>
                    <span class="n">var_list</span><span class="p">}]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.parseTree"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.parseTree">[docs]</a>    <span class="k">def</span> <span class="nf">parseTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ParseState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses the XML ast tree recursively to generate a JSON AST</span>
<span class="sd">        which can be ingested by other scripts to generate Python</span>
<span class="sd">        scripts.</span>

<span class="sd">        Args:</span>
<span class="sd">            root: The current root of the tree.</span>
<span class="sd">            state: The current state of the tree defined by an object of the</span>
<span class="sd">                ParseState class.</span>

<span class="sd">        Returns:</span>
<span class="sd">                ast: A JSON ast that defines the structure of the Fortran file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast_tag_handlers</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast_tag_handlers</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">](</span><span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">libRtns</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_libRtn</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">prog</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">prog</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">prog</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.loadFunction"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.loadFunction">[docs]</a>    <span class="k">def</span> <span class="nf">loadFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a list with all the functions in the Fortran File</span>

<span class="sd">        Args:</span>
<span class="sd">            root: The root of the XML ast tree.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        Does not return anything but populates two lists (self.functionList</span>
<span class="sd">        and self.subroutineList) that contains all the functions and</span>
<span class="sd">        subroutines in the Fortran File respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;subroutine&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.analyze"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.analyze">[docs]</a>    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">outputDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ast</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Parse through the ast once to identify and grab all the functions</span>
        <span class="c1"># present in the Fortran file.</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loadFunction</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

        <span class="c1"># Parse through the ast tree a second time to convert the XML ast</span>
        <span class="c1"># format to a format that can be used to generate Python statements.</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
            <span class="n">ast</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">ParseState</span><span class="p">())</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the entry point for the Fortran file.</span>
<span class="sd">        The entry point for a conventional Fortran file is always the PROGRAM</span>
<span class="sd">        section. This &#39;if&#39; statement checks for the presence of a PROGRAM</span>
<span class="sd">        segment.</span>

<span class="sd">        If not found, the entry point can be any of the functions or</span>
<span class="sd">        subroutines in the file. So, all the functions and subroutines of the</span>
<span class="sd">        program are listed and included as the possible entry point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryPoint</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;program&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="p">:</span>
                <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span><span class="p">:</span>
                <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;subroutine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span>

        <span class="c1"># Load the functions list and Fortran ast to a single data structure</span>
        <span class="c1"># which can be pickled and hence is portable across various scripts and</span>
        <span class="c1"># usages.</span>
        <span class="n">outputDict</span><span class="p">[</span><span class="s2">&quot;ast&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ast</span>
        <span class="n">outputDict</span><span class="p">[</span><span class="s2">&quot;functionList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span>
        <span class="k">return</span> <span class="n">outputDict</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.print_unhandled_tags"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.print_unhandled_tags">[docs]</a>    <span class="k">def</span> <span class="nf">print_unhandled_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;WARNING: input contains the following unhandled tags:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;    </span><span class="si">{tag}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="get_trees"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.get_trees">[docs]</a><span class="k">def</span> <span class="nf">get_trees</span><span class="p">(</span><span class="n">files</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span></div>


<div class="viewcode-block" id="xml_to_py"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.xml_to_py">[docs]</a><span class="k">def</span> <span class="nf">xml_to_py</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">fortran_file</span><span class="p">):</span>
    <span class="n">translator</span> <span class="o">=</span> <span class="n">XML_to_JSON_translator</span><span class="p">()</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="n">translator</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
    <span class="n">comments</span> <span class="o">=</span> <span class="n">get_comments</span><span class="p">(</span><span class="n">fortran_file</span><span class="p">)</span>
    <span class="n">output_dict</span><span class="p">[</span><span class="s2">&quot;comments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comments</span>

    <span class="c1"># print_unhandled_tags() was originally intended to alert us to program</span>
    <span class="c1"># constructs we were not handling.  It isn&#39;t clear we actually use this</span>
    <span class="c1"># so I&#39;m commenting out this call for now.  Eventually this code (and all </span>
    <span class="c1"># the code that keeps track of unhandled tags) should go away.</span>
    <span class="c1"># --SKD 06/2019</span>
    <span class="c1">#translator.print_unhandled_tags()</span>

    <span class="k">return</span> <span class="n">output_dict</span></div>


<div class="viewcode-block" id="parse_args"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.parse_args">[docs]</a><span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Parse the arguments passed to the script.  Returns a tuple </span>
<span class="sd">        (fortran_file, pickle_file, args) where fortran_file is the</span>
<span class="sd">        file containing the input Fortran code, and pickle_file is</span>
<span class="sd">        the output pickle file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--gen&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Pickled version of routines for which dependency graphs should &quot;</span>
             <span class="s2">&quot;be generated&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-f&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--files&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A list of AST files in XML format to analyze&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-i&quot;</span><span class="p">,</span> <span class="s2">&quot;--input&quot;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Original Fortran Source code file.&quot;</span>
    <span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">fortran_file</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pickle_file</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">gen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">fortran_file</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="gen_pickle_file"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.gen_pickle_file">[docs]</a><span class="k">def</span> <span class="nf">gen_pickle_file</span><span class="p">(</span><span class="n">outputDict</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pickle_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">outputDict</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="p">(</span><span class="n">fortran_file</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">()</span>
    <span class="n">trees</span> <span class="o">=</span> <span class="n">get_trees</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">files</span><span class="p">)</span>

    <span class="n">output_dict</span> <span class="o">=</span> <span class="n">xml_to_py</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">fortran_file</span><span class="p">)</span>
    
    <span class="n">gen_pickle_file</span><span class="p">(</span><span class="n">output_dict</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Adarsh

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>